<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>LifeBalance</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Balance your life with intelligent task management">
    <meta name="theme-color" content="#2196F3">
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS Specific Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="LifeBalance">
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icon.png">
    <link rel="apple-touch-icon" sizes="120x120" href="icon.png">
    <link rel="icon" type="image/png" href="icon.png">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Permanent+Marker&family=Comic+Neue:wght@400;700&display=swap');

        :root {
            /* Backgrounds */
            --lb-paper: #F7F2E8;      /* soft cream */
            --lb-panel: #FFFFFF;      /* white panels */
            --lb-toolbar: #E2D8C8;    /* muted beige bar */
            --lb-border: #B9B0A5;

            /* Accents ‚Äì soft, not bold */
            --lb-accent-blue: #6F8FAF;   /* muted dusty blue */
            --lb-accent-red:  #C45D5D;   /* brick red */
            --lb-accent-gold: #D6A85B;   /* warm gold */

            /* States */
            --lb-hover: #F4E8D6;
            --lb-selected: #EADCC8;
            --lb-today: #FBE6D2;

            /* Text */
            --lb-text-main: #222222;
            --lb-text-muted: #67625C;
        }

        /* Sprite icon system */
        .lb-sprite {
            background-image: url('lifebalance-tintin-sprite.png');
            background-repeat: no-repeat;
            background-size: 400% 200%;
            /* Approximate 4 columns √ó 2 rows sprite layout. */
        }

        .lb-icon {
            width: 18px;
            height: 18px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 6px;
        }

        /* Icon variations (approximate positions across the sprite) */
        .lb-icon-globe  { background-position: 0%   100%; }
        .lb-icon-bag    { background-position: 50%  100%; }
        .lb-icon-dog    { background-position: 100% 100%; }

        /* App badge styling */
        .lb-app-badge {
            width: 28px;
            height: 28px;
            vertical-align: middle;
            margin-right: 8px;
            border-radius: 6px;
            object-fit: cover;
            object-position: left top;  /* bias towards the top-left badge area of the sprite */
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
        }

        /* Section header decorative banner */
        .section-header {
            background: url('header-strip.png') repeat-x center;
            background-size: auto 100%;
            padding: 16px;
            margin-bottom: 16px;
            font-weight: bold;
            font-size: 20px;
            color: var(--lb-text-main);
            text-align: center;
            font-family: 'Bangers', cursive;
            letter-spacing: 2px;
            text-transform: uppercase;
            border: 3px solid #000000;
            border-radius: 0;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
            text-shadow: 2px 2px 0 rgba(255,255,255,0.5);
        }

        /* Comic-style decorative stars */
        .comic-star {
            display: inline-block;
            color: var(--lb-accent-gold);
            font-size: 20px;
            animation: twinkle 2s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        /* Speech bubble tail effect for priority tasks */
        .task-item.priority::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #FFFFFF;
            filter: drop-shadow(1px 2px 0 #000000);
        }

        /* POW! BANG! comic style accents */
        .comic-accent {
            font-family: 'Bangers', cursive;
            color: var(--lb-accent-red);
            text-shadow: 2px 2px 0 #000000;
            font-size: 24px;
            letter-spacing: 2px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

    body {
        font-family: 'Comic Neue', 'Bangers', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 14px;
        font-weight: 400;
        background: var(--lb-paper) url('background-paper.jpg') repeat;
        background-size: auto;
        color: var(--lb-text-main);
        height: 100vh;
        overflow: hidden;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
    }

    /* Optional decorative wallpaper mode */
    body.wallpaper-mode {
        background: var(--lb-paper) url('background-wallpaper.jpg') no-repeat center center fixed;
        background-size: cover;
    }
    
    /* iPad-specific optimizations */
    @media (min-width: 768px) {
        body {
            font-size: 14px;
        }
        
        .btn, button {
            min-height: 44px; /* Apple HIG minimum touch target */
            padding: 10px 16px !important;
        }
        
        .task-item {
            min-height: 44px;
            padding: 8px !important;
        }
        
        .checkbox {
            width: 20px !important;
            height: 20px !important;
        }
        
        input[type="text"],
        input[type="date"],
        input[type="time"],
        input[type="number"],
        textarea,
        select {
            font-size: 16px !important; /* Prevents iOS zoom */
            min-height: 44px;
            padding: 8px !important;
        }
        
        /* Ensure calendar grid fits on iPad screens */
        .calendar-grid {
            max-width: 100%;
            width: 100%;
        }
        
        .calendar-day {
            font-size: 11px;
            min-height: 80px;
        }
        
        .right-pane {
            padding: 8px;
            box-sizing: border-box;
        }
    }
    
    /* Prevent text selection except in inputs */
    input, textarea {
        -webkit-user-select: text;
        user-select: text;
    }


    .app-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        /* Only add safe area padding at sides, not top/bottom to avoid double padding */
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
    }

    /* Menu Bar */
    .menu-bar {
        background: var(--lb-paper);
        border-bottom: 3px solid #000000;
        padding: 8px 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        /* Safe area padding only at top for notch */
        padding-top: max(8px, env(safe-area-inset-top));
        flex-shrink: 0;
        box-shadow: 0 2px 0 rgba(0,0,0,0.2);
    }

    .menu-bar h1 {
        font-size: 18px;
        font-weight: bold;
        font-family: 'Bangers', cursive;
        letter-spacing: 1px;
    }

    /* Toolbar */
    .toolbar {
        background: var(--lb-toolbar);
        border-bottom: 3px solid #000000;
        padding: 8px;
        display: flex;
        gap: 8px;
        flex-shrink: 0;
        flex-wrap: wrap;
        box-shadow: 0 2px 0 rgba(0,0,0,0.2);
    }

    .toolbar button {
        padding: 8px 16px;
        background: var(--lb-panel);
        border: 3px solid #000000;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 6px;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
        color: var(--lb-text-main);
        font-family: 'Comic Neue', sans-serif;
        transition: all 0.1s ease;
    }

    .toolbar button:hover {
        background: var(--lb-accent-gold);
        transform: translate(-2px, -2px);
        box-shadow: 5px 5px 0 rgba(0,0,0,0.3);
    }

    .toolbar button.active {
        background: var(--lb-accent-blue);
        color: #fff;
        border-color: #000000;
        transform: translate(2px, 2px);
        box-shadow: 1px 1px 0 rgba(0,0,0,0.3);
    }

    /* Main Content */
    .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
        position: relative;
        /* Add bottom safe area padding here instead of app-container */
        padding-bottom: env(safe-area-inset-bottom);
    }

    .left-pane {
        width: 35%;
        border-right: 4px solid #000000;
        background: var(--lb-panel);
        display: flex;
        flex-direction: column;
        transition: width 0.3s ease;
        min-height: 0;
        border: 3px solid #000000;
        border-radius: 0;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }
    
    /* Expanded mode for full-screen planning */
    .left-pane.expanded {
        width: 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        z-index: 50;
        position: relative;
        background: var(--lb-panel);
    }
    
    /* Ensure outline view maintains proper flex layout in expanded mode */
    .left-pane.expanded #outline-view {
        height: 100%;
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
    }
    
    /* Ensure outline container scrolls in expanded mode */
    .left-pane.expanded .outline-container {
        position: absolute;
        top: 52px;
        bottom: 52px;
        left: 0;
        right: 0;
        overflow-y: scroll !important;
        overflow-x: hidden !important;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        touch-action: pan-y !important;
        padding: 8px;
        padding-bottom: 60px;
    }
    
    /* Ensure button group is always visible in expanded mode */
    .left-pane.expanded .button-group {
        position: sticky;
        bottom: 0;
        z-index: 100;
        flex-shrink: 0;
        padding: 8px;
        background: var(--lb-panel);
        border-top: 1px solid var(--lb-border);
    }
    
    /* Outline view needs specific flex layout for scrolling */
    #outline-view {
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
        min-height: 0;
        position: relative; /* Make this the positioning context */
    }

    .right-pane {
        flex: 1;
        background: var(--lb-panel);
        display: flex;
        flex-direction: column;
        transition: all 0.3s ease;
        min-width: 0;
        overflow: hidden;
        border: 3px solid #000000;
        border-radius: 0;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }
    
    /* Hide right pane when left pane is expanded */
    .left-pane.expanded ~ .right-pane {
        display: none;
    }

    /* Outline View */
    .outline-container {
        position: absolute;
        top: 52px; /* Height of tip banner */
        bottom: 52px; /* Height of button group */
        left: 0;
        right: 0;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 8px;
        padding-bottom: 80px; /* Extra padding so content isn't hidden under buttons */
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        -webkit-user-select: none;
        user-select: none;
        touch-action: pan-y;
    }
    
    .outline-container.drop-active {
        background: #E3F2FD;
        border: 2px dashed #2196F3;
    }
    
    .drop-hint {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 20px 30px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 1000;
        text-align: center;
    }
    
    .outline-container.drop-active .drop-hint {
        opacity: 1;
    }
    
    .drop-hint-icon {
        font-size: 32px;
        margin-bottom: 8px;
    }
    
    .drop-hint-text {
        font-size: 12px;
        font-weight: bold;
        color: #333;
    }
    
    .drop-hint-subtext {
        font-size: 10px;
        color: #666;
        margin-top: 4px;
    }

    .task-item {
        display: flex;
        align-items: center;
        padding: 4px;
        margin: 2px 0;
        cursor: pointer;
    }

    .task-item:hover {
        background: #FFE4E1;
    }

    .task-item.selected {
        background: #FFB3B3;
    }

    .task-item.completed {
        color: #808080;
        text-decoration: line-through;
    }

    .task-item.dragging {
        opacity: 0.5;
        background: #E3F2FD;
    }

    .task-item.drag-over {
        border-top: 3px solid #2196F3;
    }

    .task-item.drag-over-child {
        border-left: 3px solid #4CAF50;
        background: #E8F5E9;
    }

    .calendar-drag-over {
        background: #E3F2FD !important;
        border: 2px dashed #2196F3 !important;
        box-shadow: 0 0 8px rgba(33, 150, 243, 0.3);
        transform: scale(1.02);
        transition: all 0.2s ease;
    }

    .drag-handle {
        cursor: move;
        padding: 0 8px;
        color: #AAA;
        user-select: none;
        font-size: 16px;
        line-height: 1;
        font-weight: bold;
        min-width: 32px;
        min-height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        touch-action: none;
    }

    .drag-handle:hover {
        color: #2196F3;
        background: rgba(33, 150, 243, 0.1);
        border-radius: 4px;
    }
    
    .drag-handle:active {
        color: #1976D2;
        background: rgba(33, 150, 243, 0.2);
    }

    .task-item:hover .drag-handle {
        color: #666;
    }

    .expander {
        width: 24px;
        min-width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        font-size: 18px;
        font-weight: bold;
        flex-shrink: 0;
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(33, 150, 243, 0.3);
    }
    
    /* iPad-specific expander sizing */
    @media (min-width: 768px) {
        .expander {
            width: 36px;
            min-width: 36px;
            height: 36px;
            font-size: 24px;
        }
    }

    .checkbox {
        width: 20px;
        min-width: 20px;
        height: 20px;
        margin: 0;
        flex-shrink: 0;
        cursor: pointer;
    }

    .task-bullet {
        width: 12px;
        min-width: 12px;
        height: 12px;
        border-radius: 50%;
        margin: 0;
        flex-shrink: 0;
        border: 2px solid #000;
    }

    .task-title {
        flex: 1;
        margin: 0 4px;
        min-width: 0;
        overflow-wrap: break-word;
        word-break: break-word;
    }

    .task-due-date {
        font-size: 9px;
        padding: 2px 6px;
        border-radius: 3px;
        margin-left: 4px;
    }

    .due-overdue {
        background: #FF0000;
        color: #FFFFFF;
    }

    .due-today {
        color: #FF0000;
        font-weight: bold;
    }

    .due-tomorrow {
        color: #FF6600;
        font-weight: bold;
    }
    
    /* Time display in to-do list */
    .task-time {
        font-size: 9px;
        color: #666;
        padding: 2px 6px;
        background: #E3F2FD;
        border-radius: 3px;
        margin-left: 4px;
        font-weight: 500;
    }

    .delete-btn {
        opacity: 0;
        color: #FF0000;
        cursor: pointer;
        padding: 0 4px;
    }

    .task-item:hover .delete-btn {
        opacity: 1;
    }

    /* Task Detail */
    .task-detail {
        padding: 12px;
        border-bottom: 1px solid #D4D0C8;
    }

    .task-detail input[type="text"] {
        width: 100%;
        padding: 6px;
        border: 1px solid #808080;
        font-size: 12px;
        font-weight: bold;
    }

    .tabs {
        display: flex;
        background: #D4D0C8;
        border-bottom: 1px solid #808080;
    }

    .tab {
        padding: 8px 16px;
        cursor: pointer;
        border-right: 1px solid #808080;
        background: #E0E0E0;
    }

    .tab:hover {
        background: #D0D0D0;
    }

    .tab.active {
        background: #FFFFFF;
        border-bottom: 2px solid #FFFFFF;
    }

    .tab-content {
        flex: 1;
        padding: 16px;
        overflow-y: auto;
    }

    /* Form Controls */
    .form-group {
        margin: 12px 0;
    }

    .form-group label {
        display: block;
        margin-bottom: 4px;
        font-weight: bold;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
        width: 100%;
        padding: 6px;
        border: 1px solid #808080;
        font-size: 11px;
        font-family: inherit;
    }

    .form-group textarea {
        height: 100px;
        resize: vertical;
    }

    .slider-container {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .slider {
        flex: 1;
    }

    .slider-label {
        min-width: 80px;
        text-align: right;
    }

    /* To Do List View */
    .todo-controls {
        padding: 12px;
        background: #F0F0F0;
        border-bottom: 1px solid #D4D0C8;
        display: flex;
        gap: 12px;
        align-items: center;
    }

    .todo-list {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 8px;
        width: 100%;
    }

    .todo-item {
        background: white;
        border: 1px solid #D4D0C8;
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .todo-item:hover {
        background: #FFF8DC;
    }
    
    /* Top row: priority, checkbox, bullet, title */
    .todo-item-header {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        margin-bottom: 6px;
    }
    
    /* Priority score - small and inline */
    .todo-item .priority-score {
        font-size: 10px;
        font-weight: bold;
        min-width: 28px;
        text-align: center;
        padding: 2px 4px;
        border-radius: 3px;
        flex-shrink: 0;
    }
    
    /* Checkbox - inline */
    .todo-item .checkbox {
        width: 16px;
        height: 16px;
        margin-top: 2px;
        flex-shrink: 0;
        cursor: pointer;
    }
    
    /* Bullet - inline */
    .todo-item .task-bullet {
        margin-top: 4px;
        flex-shrink: 0;
    }
    
    /* Task title - wraps naturally like Kanban */
    .todo-item .task-title {
        flex: 1;
        font-size: 13px;
        font-weight: 500;
        color: #333;
        line-height: 1.4;
        word-wrap: break-word;
    }
    
    /* Metadata below title like Kanban */
    .todo-item-meta {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        font-size: 10px;
        color: #666;
        margin-left: 52px; /* Align with title (28px priority + 16px checkbox + 8px gap) */
    }
    
    .todo-item-meta > * {
        padding: 2px 6px;
        border-radius: 3px;
        background: #F5F5F5;
        white-space: nowrap;
    }

    .todo-item:hover {
        background: #FFF8DC;
    }

    /* Todo Card Grid Layout */
    .todo-cards-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 16px;
        padding: 16px;
        overflow-y: auto;
        flex: 1;
    }

    /* Make todo-view full width */
    #todo-view {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        background: var(--lb-panel);
        z-index: 1;
        border-radius: 0;
        border: 3px solid #000000;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }

    .todo-card {
        background: #FFFFFF;
        border-radius: 0;
        box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
        padding: 16px;
        border: 3px solid #000000;
        transition: transform 0.1s, box-shadow 0.1s;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 12px;
        position: relative;
    }

    .todo-card:hover {
        transform: translate(-2px, -2px);
        box-shadow: 6px 6px 0 rgba(0,0,0,0.3);
        background: var(--lb-hover);
    }

    .todo-card::before {
        content: '';
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        border: 2px solid #000000;
        pointer-events: none;
    }

    .todo-card-header {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        position: relative;
    }

    .todo-card-delete {
        position: absolute;
        top: 0;
        right: 0;
        width: 24px;
        height: 24px;
        border: 1px solid #D4D0C8;
        background: linear-gradient(to bottom, #FFFFFF, #F0F0F0);
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #666;
        transition: all 0.2s;
        opacity: 0;
    }

    .todo-card:hover .todo-card-delete {
        opacity: 1;
    }

    .todo-card-delete:hover {
        background: #FFE5E5;
        color: #F44336;
        border-color: #F44336;
    }

    .todo-card-delete:active {
        transform: scale(0.95);
    }

    .todo-card-checkbox {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        cursor: pointer;
        margin-top: 2px;
    }

    .todo-card-content {
        flex: 1;
        min-width: 0;
    }

    .todo-card-priority {
        font-size: 24px;
        font-weight: bold;
        font-family: 'Courier New', monospace;
        min-width: 45px;
        text-align: center;
        padding: 4px 8px;
        border-radius: 6px;
        background: #F5F5F5;
        flex-shrink: 0;
    }

    .todo-card-title {
        font-size: 16px;
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
        line-height: 1.4;
        word-wrap: break-word;
    }

    .todo-card-parent {
        font-size: 11px;
        color: #666;
        background: #F5F5F5;
        padding: 4px 8px;
        border-radius: 4px;
        display: inline-block;
        margin-bottom: 8px;
    }

    .todo-card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 11px;
    }

    .todo-card-badge {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        background: #F0F0F0;
        border-radius: 4px;
        color: #666;
        white-space: nowrap;
    }

    .todo-card-badge.time {
        background: #E3F2FD;
        color: #1976D2;
    }

    .todo-card-badge.place {
        background: #FFF3E0;
        color: #F57C00;
    }

    .todo-card-badge.duration {
        background: #F3E5F5;
        color: #7B1FA2;
    }

    .todo-card-note {
        font-size: 12px;
        color: #666;
        line-height: 1.4;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #E0E0E0;
    }

    .todo-card.completed {
        opacity: 0.6;
    }

    .todo-card.completed .todo-card-title {
        text-decoration: line-through;
    }

    /* Todo Card Timer Styles */
    .todo-card-timer {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #E0E0E0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 11px;
    }

    .timer-display {
        font-family: 'Courier New', monospace;
        font-weight: bold;
        font-size: 14px;
        color: #2196F3;
        min-width: 60px;
    }

    .timer-controls {
        display: flex;
        gap: 4px;
    }

    .timer-btn {
        padding: 4px 8px;
        border: 1px solid #D4D0C8;
        background: linear-gradient(to bottom, #FFFFFF, #F0F0F0);
        border-radius: 4px;
        cursor: pointer;
        font-size: 10px;
        transition: all 0.2s;
    }

    .timer-btn:hover {
        background: linear-gradient(to bottom, #E3F2FD, #BBDEFB);
    }

    .timer-btn.active {
        background: #4CAF50;
        color: white;
        border-color: #4CAF50;
    }

    .timer-btn.stop {
        background: #F44336;
        color: white;
        border-color: #F44336;
    }

    /* Timeline progress bar at bottom of card */
    .card-timeline {
        height: 6px;
        background: #E0E0E0;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 8px;
        position: relative;
    }

    .timeline-progress {
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #2196F3);
        transition: width 0.3s ease;
        border-radius: 3px;
    }

    .timeline-marker {
        position: absolute;
        top: -2px;
        width: 2px;
        height: 10px;
        background: #F44336;
        transition: left 0.3s ease;
    }

    .priority-score {
        font-size: 10px;
        font-weight: bold;
        font-family: 'Courier New', monospace;
        color: #666;
        min-width: 35px;
        max-width: 35px;
        width: 35px;
        flex-shrink: 0;
        flex-grow: 0;
        text-align: center;
        padding: 4px 2px;
        border-radius: 3px;
        background: #F5F5F5;
        box-sizing: border-box;
        display: inline-block;
    }

    .priority-score.high {
        background: #FFCDD2;
        color: #C62828;
    }

    .priority-score.medium {
        background: #FFF9C4;
        color: #F57F17;
    }

    .priority-score.low {
        background: #E8F5E9;
        color: #2E7D32;
    }

    /* Balance View */
    #balance-view {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 10;
        background: var(--lb-panel);
        border-radius: 0;
        border: 3px solid #000000;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }

    .balance-container {
        display: flex;
        height: 100%;
        overflow: hidden;
        gap: 1px;
        background: #D4D0C8;
        width: 100%;
    }

    .balance-left-pane {
        width: 350px;
        min-width: 350px;
        padding: 20px;
        overflow-y: auto;
        background: white;
    }

    .balance-right-pane {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .charts-container {
        display: flex;
        flex-direction: column;
        gap: 40px;
        align-items: center;
    }

    .chart-section {
        text-align: center;
    }

    .chart-section h3 {
        margin-bottom: 16px;
        font-size: 14px;
    }

    /* Envelopes View */
    #envelopes-view {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 10;
        background: var(--lb-panel);
        border-radius: 0;
        border: 3px solid #000000;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }

    .envelope-card {
        padding: 0;
        border-radius: 0;
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        transition: transform 0.2s, box-shadow 0.2s;
        cursor: pointer;
        position: relative;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    /* Envelope flap */
    .envelope-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 40%;
        background: inherit;
        filter: brightness(0.85);
        clip-path: polygon(0 0, 100% 0, 50% 60%);
        z-index: 1;
    }
    
    /* Envelope body */
    .envelope-card::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 65%;
        background: inherit;
        z-index: 0;
    }

    .envelope-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 6px 16px rgba(0,0,0,0.2);
    }

    .envelope-card-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 8px;
        padding: 16px 20px 0 20px;
        position: relative;
        z-index: 2;
    }

    .envelope-name {
        font-size: 15px;
        font-weight: 600;
        color: white;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .envelope-actions {
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.2s;
    }

    .envelope-card:hover .envelope-actions {
        opacity: 1;
    }

    .envelope-btn {
        background: rgba(255,255,255,0.25);
        border: 1px solid rgba(255,255,255,0.4);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.2s;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .envelope-btn:hover {
        background: rgba(255,255,255,0.4);
    }

    .envelope-balance {
        font-size: 28px;
        font-weight: bold;
        color: white;
        padding: 0 20px;
        position: relative;
        z-index: 2;
        text-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .envelope-hint {
        font-size: 10px;
        color: rgba(255,255,255,0.85);
        padding: 0 20px 16px 20px;
        position: relative;
        z-index: 2;
        text-shadow: 0 1px 2px rgba(0,0,0,0.15);
    }

    .financial-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        background: #E8F5E9;
        border-radius: 4px;
        color: #2E7D32;
        font-size: 11px;
        font-weight: 600;
    }

    .financial-badge.negative {
        background: #FFEBEE;
        color: #C62828;
    }

    canvas {
        border: 2px solid #808080;
        border-radius: 8px;
    }

    .legend {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 1px solid #000;
    }

    /* Places View */
    #places-view {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 10;
        background: var(--lb-panel);
        border-radius: 0;
        border: 3px solid #000000;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }

    .places-container {
        display: flex;
        height: 100%;
        overflow: hidden;
        gap: 1px;
        background: #D4D0C8;
        width: 100%;
    }

    .places-list-pane {
        width: 250px;
        min-width: 250px;
        background: white;
        padding: 8px;
        overflow-y: auto;
        padding-bottom: max(8px, env(safe-area-inset-bottom));
    }

    .places-heatmap-pane {
        flex: 1;
        padding: 16px;
        overflow-y: auto;
        background: white;
        padding-bottom: max(16px, calc(16px + env(safe-area-inset-bottom)));
    }

    .place-item {
        padding: 8px;
        margin: 2px 0;
        cursor: pointer;
        border-radius: 4px;
    }

    .place-item:hover {
        background: #F0F0F0;
    }

    .place-item.selected {
        background: #E3F2FD;
    }
    

    .heat-map {
        margin: 20px 0;
        max-width: 100%;
        overflow-x: auto;
    }

    .heat-map-grid {
        display: grid;
        grid-template-columns: auto repeat(7, 1fr);
        gap: 2px;
        font-size: 11px; /* Larger for iPad */
        min-width: 500px; /* Ensure it doesn't get squished */
    }

    .heat-map-cell {
        padding: 8px; /* Larger touch targets for iPad */
        text-align: center;
        border: 1px solid #D4D0C8;
        min-height: 44px; /* Apple touch target minimum */
    }

    .heat-map-cell.header {
        background: #E0E0E0;
        font-weight: bold;
    }

    /* Day Calendar View */
    #day-calendar-view {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 10;
        background: var(--lb-panel);
        border-radius: 0;
        border: 3px solid #000000;
        box-shadow: inset -2px -2px 0 rgba(0,0,0,0.1);
    }

    .day-calendar-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
        background: var(--lb-paper);
    }

    .day-calendar-header {
        padding: 16px;
        background: var(--lb-toolbar);
        border-bottom: 3px solid #000000;
        text-align: center;
    }

    .day-calendar-header h2 {
        font-family: 'Bangers', cursive;
        letter-spacing: 2px;
        color: var(--lb-text-main);
        text-shadow: 2px 2px 0 rgba(255,255,255,0.5);
        margin: 0 0 8px 0;
        font-size: 24px;
    }

    .day-calendar-date {
        font-size: 14px;
        color: var(--lb-text-muted);
        font-weight: bold;
    }

    .day-calendar-timeline {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        padding-bottom: max(16px, calc(16px + env(safe-area-inset-bottom)));
        position: relative;
    }

    .timeline-hour {
        display: flex;
        border-bottom: 2px solid var(--lb-border);
        min-height: 60px;
        position: relative;
    }

    .timeline-hour:last-child {
        border-bottom: 3px solid #000000;
    }

    .hour-label {
        width: 80px;
        min-width: 80px;
        padding: 8px;
        font-family: 'Comic Neue', cursive;
        font-weight: bold;
        font-size: 14px;
        color: var(--lb-text-muted);
        border-right: 3px solid #000000;
        background: var(--lb-toolbar);
        text-align: center;
    }

    .hour-content {
        flex: 1;
        position: relative;
        background: var(--lb-panel);
    }

    .appointment-block {
        position: absolute;
        left: 8px;
        right: 8px;
        background: #B8C5D6; /* Muted slate blue */
        border: 2px solid #8A9BAE;
        border-radius: 6px;
        padding: 8px;
        box-shadow: 2px 2px 4px rgba(0,0,0,0.15);
        cursor: pointer;
        transition: all 0.2s;
    }

    .appointment-block:hover {
        transform: translate(-1px, -1px);
        box-shadow: 3px 3px 6px rgba(0,0,0,0.2);
    }

    .appointment-title {
        font-family: 'Comic Neue', cursive;
        font-weight: bold;
        font-size: 13px;
        color: var(--lb-text-main);
        margin-bottom: 4px;
    }

    .appointment-time {
        font-size: 11px;
        color: var(--lb-text-muted);
        font-weight: bold;
    }

    .gap-indicator {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background: #F5F5F0;
        border: 1px solid #9B9B8F;
        border-radius: 4px;
        padding: 4px 10px;
        font-size: 10px;
        font-weight: 600;
        color: #6B6B60;
        white-space: nowrap;
        pointer-events: none;
        font-family: 'Comic Neue', cursive;
        letter-spacing: 0.5px;
        text-transform: lowercase;
    }

    .now-indicator {
        position: absolute;
        left: 80px;
        right: 0;
        height: 3px;
        background: var(--lb-accent-red);
        z-index: 100;
        pointer-events: none;
    }

    .now-indicator::before {
        content: 'NOW';
        position: absolute;
        left: 8px;
        top: -10px;
        background: var(--lb-accent-red);
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: bold;
        font-family: 'Bangers', cursive;
        letter-spacing: 1px;
    }

    /* Clickable time slots */
    .hour-content {
        cursor: pointer;
    }

    .hour-content:hover {
        background: var(--lb-hover);
    }

    .gap-indicator {
        cursor: pointer;
        pointer-events: auto;
        transition: all 0.2s;
    }

    .gap-indicator:hover {
        background: #8A9BAE;
        color: white;
        border-color: #6F8FAF;
        transform: translateX(-50%) scale(1.05);
    }

    /* Calendar note markers */
    .note-marker {
        position: absolute;
        right: 4px;
        top: 4px;
        width: 20px;
        height: 20px;
        background: var(--lb-accent-gold);
        border: 2px solid #000000;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
        z-index: 50;
    }

    .note-marker:hover {
        transform: scale(1.2);
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .note-marker::after {
        content: 'üìù';
    }


    /* Task creation modal */
    .calendar-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }

    .calendar-modal-content {
        background: var(--lb-paper);
        border: 4px solid #000000;
        border-radius: 12px;
        padding: 24px;
        max-width: 500px;
        width: 100%;
        box-shadow: 8px 8px 0 rgba(0,0,0,0.3);
        max-height: 80vh;
        overflow-y: auto;
    }

    .calendar-modal-header {
        font-family: 'Bangers', cursive;
        font-size: 20px;
        letter-spacing: 2px;
        color: var(--lb-text-main);
        text-shadow: 2px 2px 0 rgba(255,255,255,0.5);
        margin-bottom: 16px;
        text-align: center;
    }

    .calendar-modal-time {
        background: var(--lb-accent-blue);
        border: 2px solid #000000;
        padding: 8px;
        border-radius: 8px;
        text-align: center;
        font-weight: bold;
        margin-bottom: 16px;
        font-family: 'Comic Neue', cursive;
    }

    .calendar-form-group {
        margin-bottom: 16px;
    }

    .calendar-form-group label {
        display: block;
        font-weight: bold;
        margin-bottom: 6px;
        font-family: 'Comic Neue', cursive;
        color: var(--lb-text-main);
    }

    .calendar-form-group input,
    .calendar-form-group select,
    .calendar-form-group textarea {
        width: 100%;
        padding: 8px;
        border: 3px solid #000000;
        border-radius: 6px;
        font-size: 13px;
        font-family: 'Comic Neue', cursive;
        background: white;
    }

    .calendar-form-group input:focus,
    .calendar-form-group select:focus,
    .calendar-form-group textarea:focus {
        outline: none;
        border-color: var(--lb-accent-blue);
    }

    .duration-display {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
    }

    .duration-value {
        font-weight: bold;
        color: var(--lb-accent-blue);
        min-width: 60px;
    }

    .calendar-modal-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 20px;
    }
    
    .calendar-modal-buttons .btn-save {
        grid-column: 2;
    }

    .calendar-modal-buttons button {
        flex: 1;
        padding: 10px;
        border: 3px solid #000000;
        border-radius: 8px;
        font-family: 'Bangers', cursive;
        font-size: 14px;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.1s;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.2);
    }

    .calendar-modal-buttons button:hover {
        transform: translate(-2px, -2px);
        box-shadow: 5px 5px 0 rgba(0,0,0,0.3);
    }

    .calendar-modal-buttons button:active {
        transform: translate(0, 0);
        box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
    }

    .calendar-modal-buttons .btn-save {
        background: var(--lb-accent-blue);
        color: white;
    }

    .calendar-modal-buttons .btn-cancel {
        background: var(--lb-toolbar);
        color: var(--lb-text-main);
    }

    .calendar-modal-buttons .btn-delete {
        background: var(--lb-accent-red);
        color: white;
    }

    /* Week View */
    .week-view-container {
        display: grid;
        grid-template-columns: 80px repeat(7, 1fr);
        gap: 2px;
        overflow-x: auto;
        height: 100%;
    }

    .week-hour-label {
        grid-column: 1;
        border-right: 3px solid #000000;
        background: var(--lb-toolbar);
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: 'Comic Neue', cursive;
        font-weight: bold;
        font-size: 11px;
        color: var(--lb-text-muted);
        min-height: 60px;
        border-bottom: 2px solid var(--lb-border);
    }

    .week-day-column {
        position: relative;
        background: var(--lb-panel);
        min-width: 120px;
    }

    .week-day-header {
        position: sticky;
        top: 0;
        background: var(--lb-toolbar);
        border: 2px solid #000000;
        padding: 8px 4px;
        text-align: center;
        font-family: 'Comic Neue', cursive;
        font-weight: bold;
        font-size: 11px;
        z-index: 10;
    }

    .week-day-header.today {
        background: var(--lb-accent-blue);
        color: white;
    }

    .week-hour-slot {
        min-height: 60px;
        border-bottom: 2px solid var(--lb-border);
        position: relative;
        cursor: pointer;
    }

    .week-hour-slot:hover {
        background: var(--lb-hover);
    }

    .week-appointment {
        position: absolute;
        left: 2px;
        right: 2px;
        background: #B8C5D6;
        border: 2px solid #8A9BAE;
        border-radius: 4px;
        padding: 4px;
        cursor: pointer;
        transition: all 0.2s;
        overflow: hidden;
        font-size: 10px;
        line-height: 1.2;
    }

    .week-appointment:hover {
        transform: scale(1.02);
        z-index: 5;
        box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    }

    .week-appointment-title {
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .week-appointment-time {
        font-size: 9px;
        color: var(--lb-text-muted);
    }


    .heat-map-cell.hour {
        background: #F0F0F0;
    }

    .heat-map-cell.closed {
        background: #808080;
        cursor: pointer;
    }

    .heat-map-cell.open {
        background: #FFFFB3;
        cursor: pointer;
    }

    .heat-map-cell.time:hover {
        border: 2px solid #2196F3;
    }

    /* Buttons */
    .button-group {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        /* Add safe area padding at bottom */
        padding-bottom: max(8px, env(safe-area-inset-bottom));
        flex-shrink: 0; /* Prevent buttons from being compressed */
        background: white; /* Ensure buttons have background */
        border-top: 1px solid #D4D0C8; /* Visual separation */
    }
    
    /* Position button-group at bottom of outline-view */
    #outline-view .button-group {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        margin-top: 0;
        padding: 8px;
        z-index: 100;
    }

    .btn {
        padding: 8px 16px;
        background: var(--lb-panel);
        border: 3px solid #000000;
        border-radius: 8px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 700;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
        color: var(--lb-text-main);
        font-family: 'Comic Neue', sans-serif;
        transition: all 0.1s ease;
    }

    .btn:hover {
        background: var(--lb-accent-gold);
        transform: translate(-1px, -1px);
        box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
    }

    .btn-primary {
        background: var(--lb-accent-blue);
        color: white;
        border-color: #000000;
    }

    .btn-primary:hover {
        background: var(--lb-accent-blue);
        opacity: 0.9;
        transform: translate(-1px, -1px);
        box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
    }
    
    .btn-compact {
        padding: 8px 12px !important;
        min-width: 44px;
        font-size: 16px;
        font-weight: bold;
    }
    
    @media (min-width: 768px) {
        .btn-compact {
            font-size: 18px;
        }
    }

    /* Calendar */
    .calendar-container {
        padding: 16px;
        padding-bottom: max(16px, calc(16px + env(safe-area-inset-bottom)));
        background: var(--lb-panel);
        border-radius: 0;
        border: 3px solid #000000;
        box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
    }

    .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
    }

    .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 4px;
        width: 100%;
        max-width: 100%;
        overflow: hidden;
    }

    .calendar-day {
        min-height: 70px;
        border: 2px solid #000000;
        padding: 4px;
        font-size: 11px;
        font-weight: 700;
        background: #FFFDF8;
        display: flex;
        flex-direction: column;
        min-width: 0;
        overflow: hidden;
        box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
        transition: all 0.1s ease;
    }

    .calendar-day:hover {
        background: var(--lb-accent-gold);
        transform: translate(-1px, -1px);
        box-shadow: 3px 3px 0 rgba(0,0,0,0.2);
    }

    .calendar-day.today {
        background: var(--lb-today);
        border: 3px solid var(--lb-accent-red);
        font-weight: bold;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
    }

    .calendar-day.has-tasks {
        background: #FFF9E0;
    }
    
    .calendar-day.today.has-tasks {
        background: var(--lb-today);
    }

    /* Modal */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
    }

    .modal.show {
        display: flex;
    }

    .modal-content {
        background: #FFFFFF;
        border: 2px solid #808080;
        border-radius: 8px;
        padding: 20px;
        max-width: 500px;
        width: 90%;
    }

    .modal-header {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 16px;
    }

    .modal-footer {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        margin-top: 16px;
    }

    /* Color indicators */
    .color-red { background-color: #FFB3B3; }
    .color-green { background-color: #B3FFB3; }
    .color-blue { background-color: #B3D9FF; }
    .color-yellow { background-color: #FFFFB3; }
    .color-purple { background-color: #D9B3FF; }
    .color-pink { background-color: #FFCCFF; }
    .color-orange { background-color: #FFD9B3; }

    /* Toast notifications */
    .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 16px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        max-width: 400px;
        font-size: 12px;
    }

    .toast.hide {
        animation: slideOut 0.3s ease-in forwards;
    }

    @keyframes slideIn {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(400px);
            opacity: 0;
        }
    }

    /* Keyboard Navigation - Selected Task Highlight */
    .task-item.selected {
        background: #E3F2FD !important;
        border-left: 3px solid #2196F3;
        padding-left: 17px;
    }

    .task-item.selected .task-title {
        font-weight: bold;
    }
    
    /* Day detail modal for expandable calendar */
    .day-detail-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10001;
        align-items: center;
        justify-content: center;
    }
    
    .day-detail-modal.active {
        display: flex;
    }
    
    .day-detail-content {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        max-width: 600px;
        max-height: 80vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 2px solid #808080;
    }
    
    .day-detail-header {
        background: linear-gradient(to bottom, #90CAF9, #64B5F6);
        padding: 16px;
        border-bottom: 2px solid #2196F3;
    }
    
    .day-detail-header h3 {
        font-size: 16px;
        margin: 0;
    }
    
    .day-detail-body {
        padding: 16px;
        overflow-y: auto;
        flex: 1;
    }
    
    .day-appointment {
        padding: 12px;
        margin: 8px 0;
        background: #F9F9F9;
        border: 1px solid #D4D0C8;
        border-radius: 4px;
        border-left: 4px solid #64B5F6;
        cursor: pointer;
    }
    
    .day-appointment:hover {
        background: #E3F2FD;
    }
    
    .appointment-time {
        font-size: 12px;
        font-weight: bold;
        color: #2196F3;
        margin-bottom: 6px;
    }
    
    .appointment-title {
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 4px;
    }
    
    .appointment-context {
        font-size: 10px;
        color: #666;
        font-style: italic;
    }
    
    .day-detail-footer {
        padding: 12px 16px;
        border-top: 1px solid #D4D0C8;
        background: #F0F0F0;
        text-align: right;
    }
    
    .day-detail-footer button {
        padding: 8px 16px;
        background: linear-gradient(to bottom, #FFFFFF, #D4D0C8);
        border: 1px solid #808080;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
    }
    
    .day-detail-footer button:hover {
        background: linear-gradient(to bottom, #E3F2FD, #BBDEFB);
    }
</style>
</head>
<body>
    <!-- Day Detail Modal for expandable calendar -->
    <div id="day-detail-modal" class="day-detail-modal">
        <div class="day-detail-content">
            <div class="day-detail-header">
                <h3 id="day-detail-title">Appointments</h3>
            </div>
            <div class="day-detail-body" id="day-detail-list">
            </div>
            <div class="day-detail-footer">
                <button onclick="app.closeDayDetail()">Close</button>
            </div>
        </div>
    </div>

    <div class="app-container">
        <!-- Menu Bar -->
        <div class="menu-bar">
            <h1 style="font-family: 'Bangers', cursive; letter-spacing: 2px; color: var(--lb-text-main); text-shadow: 2px 2px 0 rgba(255,255,255,0.5);">LifeBalance</h1>
            <div style="display: flex; gap: 8px; align-items: center;">
                <div id="sync-status" style="font-size: 10px; color: #666; margin-right: 8px;">
                    <span id="sync-status-text">Not synced</span>
                </div>
                <button class="btn" onclick="app.setupGistSync()" id="btn-setup-gist">
                    üîß Setup Gist Sync
                </button>
                <button class="btn" onclick="app.syncNow()" id="btn-sync" style="display: none;">
                    üîÑ Sync Now
                </button>
                <button class="btn" onclick="app.disconnectGist()" id="btn-disconnect" style="display: none;">
                    ‚ùå Disconnect
                </button>
                <button class="btn" onclick="app.importPreplyLessons()">
                    üéì Import Preply Lessons
                </button>
                <button class="btn" onclick="app.exportData()">Export</button>
                <button class="btn" onclick="app.importData()">Import</button>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button id="btn-outline" class="active" onclick="app.switchView('outline')">
                ‚ò∞ Outline
            </button>
            <button id="btn-todo" onclick="app.switchView('todo')">
                <span class="lb-icon lb-sprite lb-icon-dog"></span>
                To Do List
            </button>
            <button id="btn-day-calendar" onclick="app.switchView('day-calendar')">
                üìÖ Day Calendar
            </button>
            <button id="btn-places" onclick="app.switchView('places')">
                <span class="lb-icon lb-sprite lb-icon-globe"></span>
                Places
            </button>
            <button id="btn-balance" onclick="app.switchView('balance')">
                ‚óè Balance
            </button>
            <button id="btn-envelopes" onclick="app.switchView('envelopes')">
                üí∞ Envelopes
            </button>
            <button id="btn-datalog" onclick="app.switchView('datalog')">
                üìì Data Log
            </button>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Pane -->
            <div class="left-pane">
                <!-- Outline View -->
                <div id="outline-view" class="view-content">
                    <div style="padding: 8px; background: #FFF8DC; border-bottom: 1px solid #D4D0C8; font-size: 10px;">
                        üí° <strong>Tip:</strong> Drag tasks by the ‚ãÆ‚ãÆ handle to reorder ‚Ä¢ Drop indented text to create task hierarchies
                    </div>
                    <div class="outline-container" id="outline-container">
                        <div class="drop-hint">
                            <div class="drop-hint-icon">üìã</div>
                            <div class="drop-hint-text">Drop your indented list here</div>
                            <div class="drop-hint-subtext">Indentation creates subtasks</div>
                        </div>
                    </div>
                    <div class="button-group" style="padding: 8px;">
                        <button class="btn btn-primary" onclick="app.addTask()">New Task</button>
                        <button class="btn" onclick="app.addSubtask()">New Subtask</button>
                        <button class="btn btn-compact" onclick="app.expandAll()">‚ñº</button>
                        <button class="btn btn-compact" onclick="app.collapseAll()">‚ñ∂</button>
                        <button class="btn" onclick="app.toggleOutlineExpand()" id="btn-expand-outline" title="Expand for full-screen planning">‚¨å Expand</button>
                    </div>
                </div>
            </div>

            <!-- To Do List View (Full Width) -->
            <div id="todo-view" class="view-content" style="display: none; flex-direction: column; height: 100%; overflow: hidden;">
                <div class="todo-controls">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <div style="background: #E8F5E9; padding: 4px 8px; border-radius: 4px; border: 1px solid #4CAF50;">
                            <strong>üìÖ Now:</strong> <span id="current-time-display" style="font-weight: normal;"></span>
                        </div>
                        <label>Place:</label>
                        <select id="place-filter" onchange="app.updateTodoList()">
                            <option value="all">All places</option>
                        </select>
                        <label>
                            <input type="checkbox" id="include-closed" onchange="app.updateTodoList()">
                            Include closed places
                        </label>
                    </div>
                </div>
                <div style="padding: 8px; background: #E3F2FD; border-bottom: 1px solid #2196F3; font-size: 10px;">
                    <strong>üéØ Smart Filtering:</strong> Automatically shows only tasks you can do right now based on place availability
                </div>
                <div class="todo-cards-grid" id="todo-cards-grid"></div>
                <div style="padding: 8px; display: flex; justify-content: space-between; align-items: center; background: #F0F0F0; border-top: 1px solid #D4D0C8; flex-shrink: 0;">
                    <button class="btn btn-primary" onclick="app.updateTodoList()">üîÑ Update Priorities</button>
                    <span id="last-update" style="font-size: 9px; color: #666;"></span>
                </div>
            </div>

            <!-- Day Calendar View (Full Width) -->
            <div id="day-calendar-view" class="view-content" style="display: none;">
                <div class="day-calendar-container">
                    <div class="day-calendar-header">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <button class="btn" onclick="app.changeCalendarDate(-1)" title="Previous day/week">
                                ‚óÄ
                            </button>
                            <div style="text-align: center; flex: 1;">
                                <h2 style="margin: 0;">üìÖ DAY CALENDAR</h2>
                                <div class="day-calendar-date" id="day-calendar-date"></div>
                            </div>
                            <button class="btn" onclick="app.changeCalendarDate(1)" title="Next day/week">
                                ‚ñ∂
                            </button>
                        </div>
                        <div style="display: flex; gap: 8px; justify-content: center;">
                            <button class="btn" onclick="app.jumpToToday()">
                                üìç Today
                            </button>
                            <button class="btn" onclick="app.quickCalendarNote()" style="background: var(--lb-accent-gold); color: white;">
                                üìù Quick Note
                            </button>
                            <button class="btn" id="btn-calendar-day" onclick="app.setCalendarViewMode('day')" style="background: var(--lb-accent-blue); color: white;">
                                Day
                            </button>
                            <button class="btn" id="btn-calendar-week" onclick="app.setCalendarViewMode('week')">
                                Week
                            </button>
                        </div>
                    </div>
                    <div class="day-calendar-timeline" id="day-calendar-timeline">
                        <!-- Timeline will be generated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Places View (Full Width) -->
            <div id="places-view" class="view-content places-container" style="display: none;">
                <div class="places-list-pane" id="places-list-pane">
                    <div id="places-list"></div>
                    <div id="place-controls" style="margin-top: 16px;">
                        <p>Select a place to configure</p>
                    </div>
                </div>
                <div class="places-heatmap-pane" id="places-heatmap-pane">
                    <p>Select a place to view its schedule</p>
                </div>
            </div>

            <!-- Balance View (Full Width) -->
            <div id="balance-view" class="view-content balance-container" style="display: none;">
                <div class="balance-left-pane" id="balance-left-pane">
                    <h2 class="section-header">Life Balance Overview</h2>
                    <div class="legend" id="balance-legend"></div>
                    <div style="margin-top: 20px; padding: 16px; background: #FFF3E0; border-radius: 8px; border: 1px solid #FFB74D;">
                        <h4 style="margin: 0 0 8px 0; color: #E65100;">üóëÔ∏è Cleanup Options</h4>
                        <p style="margin: 0 0 12px 0; font-size: 11px; color: #666;">
                            Remove completed tasks from your database to keep it clean and fast.
                        </p>
                        <button class="btn" onclick="app.purgeCompletedTasks()" style="background: #FF6B6B; color: white;">
                            Purge All Completed Tasks
                        </button>
                    </div>
                </div>
                <div class="balance-right-pane" id="balance-right-pane">
                    <div class="charts-container">
                        <div class="chart-section">
                            <h3>Desired Balance</h3>
                            <p style="font-size: 11px; color: #2196F3; margin-bottom: 8px; font-weight: bold;">
                                üëÜ Click around the edge to adjust the boundary
                            </p>
                            <canvas id="desired-chart" width="250" height="250"></canvas>
                        </div>
                        <div class="chart-section">
                            <h3>Actual Balance (This Week)</h3>
                            <canvas id="actual-chart" width="250" height="250"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Envelopes View -->
            <div id="envelopes-view" class="view-content" style="display: none; padding: 20px; overflow-y: auto;">
                <h2 class="section-header">üí∞ Financial Envelopes</h2>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 24px;">
                    <!-- Income Envelope (Left) -->
                    <div>
                        <h3 style="margin-bottom: 12px;">Income Envelope</h3>
                        <div id="income-envelope" style="background: linear-gradient(135deg, #4CAF50, #66BB6A); color: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-height: 150px; display: flex; flex-direction: column; justify-content: space-between;">
                            <div>
                                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 8px;">Available to Allocate</div>
                                <div style="font-size: 36px; font-weight: bold;" id="income-balance">$0.00</div>
                            </div>
                            <div style="font-size: 11px; opacity: 0.8; margin-top: 12px;">
                                Money from completed tasks lands here
                            </div>
                        </div>
                    </div>
                    
                    <!-- Budget Envelopes (Right) -->
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="margin: 0;">Budget Envelopes</h3>
                            <div style="display: flex; gap: 12px; align-items: center;">
                                <div style="font-size: 14px; color: #666;">
                                    Total: <span id="envelopes-total" style="font-weight: bold; color: #2196F3;">$0.00</span>
                                </div>
                                <button class="btn" onclick="app.createNewEnvelope()" style="padding: 6px 12px; font-size: 11px;">
                                    ‚ûï New Envelope
                                </button>
                            </div>
                        </div>
                        <div id="budget-envelopes" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                            <!-- Envelopes will be rendered here -->
                        </div>
                    </div>
                </div>
                
                <!-- Transfer Section -->
                <div style="background: #F5F5F5; padding: 20px; border-radius: 8px; border: 2px solid #D4D0C8; margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px;">üí∏ Transfer Money</h3>
                    <div style="display: grid; grid-template-columns: 1fr auto 1fr auto; gap: 12px; align-items: end;">
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">From</label>
                            <select id="transfer-from" style="width: 100%; padding: 8px; border: 1px solid #D4D0C8;">
                                <option value="income">Income Envelope</option>
                            </select>
                        </div>
                        <div style="padding-bottom: 8px; font-size: 20px;">‚Üí</div>
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">To</label>
                            <select id="transfer-to" style="width: 100%; padding: 8px; border: 1px solid #D4D0C8;">
                                <option value="">Select envelope...</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">Amount</label>
                            <input type="number" id="transfer-amount" step="0.01" min="0" placeholder="0.00" style="width: 100px; padding: 8px; border: 1px solid #D4D0C8;">
                        </div>
                    </div>
                    <button class="btn" onclick="app.transferMoney()" style="margin-top: 12px; background: #2196F3; color: white;">
                        Transfer
                    </button>
                </div>

                <!-- Expense Logging Section -->
                <div style="background: #FFF8E1; padding: 20px; border-radius: 8px; border: 2px solid #FFB74D; margin-bottom: 24px;">
                    <h3 style="margin-bottom: 16px;">üìù Log Expense</h3>
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 3fr auto; gap: 12px; align-items: end;">
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">Envelope</label>
                            <select id="expense-envelope" style="width: 100%; padding: 8px; border: 1px solid #D4D0C8;">
                                <option value="">Select envelope...</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">Amount</label>
                            <input type="number" id="expense-amount" step="0.01" min="0" placeholder="0.00" style="width: 100%; padding: 8px; border: 1px solid #D4D0C8;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">Date</label>
                            <input type="date" id="expense-date" style="width: 100%; padding: 8px; border: 1px solid #D4D0C8;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px;">Description</label>
                            <input type="text" id="expense-description" placeholder="What was this for?" style="width: 100%; padding: 8px; border: 1px solid #D4D0C8;">
                        </div>
                        <div>
                            <button class="btn" onclick="app.logExpense()" style="background: #FF6B6B; color: white; padding: 8px 16px;">
                                Log Expense
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Expense History -->
                <div style="background: #F5F5F5; padding: 20px; border-radius: 8px; border: 2px solid #D4D0C8;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="margin: 0;">üìä Expense History</h3>
                        <button class="btn" onclick="app.exportExpensesCSV()" style="background: #4CAF50; color: white; padding: 6px 12px; font-size: 11px;">
                            üì• Export CSV
                        </button>
                    </div>
                    <div id="expense-history" style="max-height: 400px; overflow-y: auto;">
                        <!-- Expenses will be rendered here -->
                        <div style="text-align: center; color: #999; padding: 40px;">
                            No expenses logged yet
                        </div>
                    </div>
                </div>
            </div>

            <!-- Data Log View -->
            <div id="datalog-view" class="view-content" style="display: none; padding: 20px; overflow-y: auto;">
                <h2 class="section-header">üìì Data Log - Reporter's Notebook</h2>
                
                <div style="background: url('header-strip.png') repeat-x center; background-size: auto 100%; padding: 12px; margin-bottom: 20px; border: 3px solid #000000; border-radius: 0; box-shadow: 4px 4px 0 rgba(0,0,0,0.3);">
                    <div style="font-family: 'Comic Neue', cursive; font-size: 12px; text-align: center;">
                        ‚úçÔ∏è Document your adventures, attach evidence, and export your discoveries!
                    </div>
                </div>

                <!-- Add Entry Section -->
                <div id="log-form" style="background: #FFF8DC; padding: 20px; border: 3px solid #000000; border-radius: 0; box-shadow: 4px 4px 0 rgba(0,0,0,0.3); margin-bottom: 24px;">
                    <h3 style="font-family: 'Bangers', cursive; letter-spacing: 1px; margin-bottom: 16px;">üìù NEW ENTRY</h3>
                    <div style="display: grid; gap: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px; font-weight: bold;">Title</label>
                            <input type="text" id="log-title" placeholder="Give your entry a headline..." style="width: 100%; padding: 8px; border: 2px solid #000000; font-family: 'Comic Neue', cursive;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 11px; font-weight: bold;">Content</label>
                            <textarea id="log-content" placeholder="Write your observations here..." style="width: 100%; min-height: 120px; padding: 8px; border: 2px solid #000000; font-family: 'Comic Neue', cursive; resize: vertical;"></textarea>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-size: 11px; font-weight: bold;">Category</label>
                                <select id="log-category" style="width: 100%; padding: 8px; border: 2px solid #000000;">
                                    <option value="General">üìã General</option>
                                    <option value="Investigation">üîç Investigation</option>
                                    <option value="Adventure">üó∫Ô∏è Adventure</option>
                                    <option value="Discovery">üí° Discovery</option>
                                    <option value="Meeting">üë• Meeting</option>
                                    <option value="Research">üìö Research</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-size: 11px; font-weight: bold;">Date</label>
                                <input type="date" id="log-date" style="width: 100%; padding: 8px; border: 2px solid #000000;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 4px; font-size: 11px; font-weight: bold;">Attach Files</label>
                                <input type="file" id="log-attachment" multiple accept="image/*,.pdf,.txt,.doc,.docx" style="width: 100%; padding: 6px; border: 2px solid #000000; font-size: 10px;">
                            </div>
                        </div>
                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button class="btn" onclick="app.clearLogEntry()" style="padding: 8px 16px;">
                                Clear
                            </button>
                            <button class="btn" onclick="app.saveLogEntry()" style="background: #C45D5D; color: white; padding: 8px 24px; font-family: 'Bangers', cursive; letter-spacing: 1px;">
                                üíæ SAVE ENTRY
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Export Section -->
                <div style="display: flex; gap: 12px; margin-bottom: 24px;">
                    <button class="btn" onclick="app.exportDataLogOPML()" style="flex: 1; background: #6F8FAF; color: white; padding: 12px; font-family: 'Bangers', cursive; letter-spacing: 1px;">
                        üì§ EXPORT OPML
                    </button>
                    <button class="btn" onclick="app.exportDataLogJSON()" style="flex: 1; background: #D6A85B; color: white; padding: 12px; font-family: 'Bangers', cursive; letter-spacing: 1px;">
                        üì¶ EXPORT JSON
                    </button>
                </div>

                <!-- Log Entries Display -->
                <div id="log-entries-container">
                    <!-- Entries will be rendered here -->
                    <div style="text-align: center; color: #999; padding: 60px; background: var(--lb-paper); border: 3px dashed #000000;">
                        <div style="font-size: 48px; margin-bottom: 12px;">üìì</div>
                        <div style="font-family: 'Comic Neue', cursive; font-size: 16px;">
                            Your notebook is empty. Start logging your adventures!
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Pane -->
            <div class="right-pane">
                <div class="task-detail" id="task-detail">
                    <input type="text" id="task-title-input" placeholder="Task title..." onchange="app.updateTaskTitle()">
                </div>
                
                <div class="tabs">
                    <div class="tab active" data-tab="general" onclick="app.switchTab('general')">General</div>
                    <div class="tab" data-tab="time" onclick="app.switchTab('time')">Time</div>
                    <div class="tab" data-tab="effort" onclick="app.switchTab('effort')">Effort</div>
                    <div class="tab" data-tab="note" onclick="app.switchTab('note')">Note</div>
                </div>

                <div class="tab-content" id="tab-content">
                    <!-- General Tab -->
                    <div id="tab-general" class="tab-panel">
                        <div class="form-group">
                            <label>Importance</label>
                            <div>of: <span id="importance-of"></span></div>
                            <div>to: <span id="importance-to"></span></div>
                            <div class="slider-container">
                                <span style="font-size: 9px;">Trivial</span>
                                <input type="range" class="slider" id="importance-slider" 
                                       min="0" max="100" value="50" 
                                       onchange="app.updateImportance()">
                                <span style="font-size: 9px;">Critical</span>
                                <span class="slider-label" id="importance-label">Essential</span>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>Place</label>
                            <select id="task-place" onchange="app.updateTaskPlace()">
                                <option value="Anywhere">Anywhere</option>
                            </select>
                        </div>

                        <div class="form-group" id="color-group" style="display: none;">
                            <label>Color (for top-level tasks)</label>
                            <select id="task-color" onchange="app.updateTaskColor()">
                                <option value="red">Red</option>
                                <option value="green">Green</option>
                                <option value="blue">Blue</option>
                                <option value="yellow">Yellow</option>
                                <option value="purple">Purple</option>
                                <option value="pink">Pink</option>
                                <option value="orange">Orange</option>
                            </select>
                        </div>

                        <div class="form-group" id="weight-group" style="display: none;">
                            <label>Weight (% of time desired)</label>
                            <input type="number" id="task-weight" min="0" max="100" 
                                   onchange="app.updateTaskWeight()">
                        </div>

                        <div class="calendar-container">
                            <div class="calendar-header">
                                <button class="btn" onclick="app.prevMonth()">‚óÄ</button>
                                <span id="calendar-month"></span>
                                <button class="btn" onclick="app.nextMonth()">‚ñ∂</button>
                            </div>
                            <div style="font-size: 9px; color: #666; margin: 2px 0 4px 0; text-align: center;">
                                üí° Drag tasks from outline onto dates to schedule | Click tasks to jump to them
                            </div>
                            <div class="calendar-grid" id="mini-calendar"></div>
                        </div>
                    </div>

                    <!-- Time Tab -->
                    <div id="tab-time" class="tab-panel" style="display: none;">
                        <!-- Live Progress Bar for current task -->
                        <div id="task-progress-container" style="display: none; margin-bottom: 16px; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; color: white;">
                            <div style="font-size: 12px; font-weight: bold; margin-bottom: 8px; display: flex; justify-content: space-between;">
                                <span id="progress-title">‚è±Ô∏è In Progress</span>
                                <span id="progress-time"></span>
                            </div>
                            <div style="background: rgba(255,255,255,0.3); height: 40px; border-radius: 12px; overflow: visible; position: relative;">
                                <div id="progress-bar" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); transition: width 1s linear; width: 0%; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; font-size: 11px; font-weight: bold; position: relative;">
                                    <span id="progress-percentage" style="position: absolute; right: 8px;"></span>
                                    <!-- Running adventurer character -->
                                    <div style="position: absolute; right: -20px; top: 50%; transform: translateY(-50%); width: 60px; height: 60px; background-image: url('runner-hero.png'); background-size: contain; background-repeat: no-repeat; background-position: center; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); z-index: 10;"></div>
                                </div>
                            </div>
                            <div style="font-size: 10px; margin-top: 6px; display: flex; justify-content: space-between; opacity: 0.9;">
                                <span id="progress-elapsed">Elapsed: 0m</span>
                                <span id="progress-remaining">Remaining: 0m</span>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Due Date</label>
                            <input type="date" id="task-due-date" onchange="app.updateTaskDate()">
                        </div>

                        <div class="form-group">
                            <label>Due Time (optional - makes it an event)</label>
                            <input type="time" id="task-due-time" onchange="app.updateTaskTime()">
                        </div>

                        <div class="form-group">
                            <label>Duration (minutes)</label>
                            <input type="number" id="task-duration" min="0" onchange="app.updateTaskDuration()">
                        </div>

                        <div class="form-group">
                            <label>Financial Value ($)</label>
                            <input type="number" id="task-financial-value" step="0.01" onchange="app.updateTaskFinancialValue()" placeholder="0.00">
                            <small style="color: #666; font-size: 9px; display: block; margin-top: 4px;">Positive for income, negative for expenses. Added to Income envelope when completed.</small>
                        </div>

                        <div class="form-group">
                            <label>Start Date (don't show before this)</label>
                            <input type="date" id="task-start-date" onchange="app.updateTaskStartDate()">
                        </div>

                        <div class="form-group">
                            <label>Lead Time (days before due to appear in To Do List)</label>
                            <input type="number" id="task-lead-time" min="0" onchange="app.updateTaskLeadTime()" placeholder="0">
                            <small style="color: #666; font-size: 9px; display: block; margin-top: 4px;">0 = Only show on due date. 1 = Show 1 day early, etc.</small>
                        </div>

                        <div class="form-group">
                            <label>Recurrence</label>
                            <select id="task-recurrence" onchange="app.updateTaskRecurrence()">
                                <option value="none">None</option>
                                <option value="daily">Daily</option>
                                <option value="every-x-days">Every X Days</option>
                                <option value="weekly">Weekly (Specific Days)</option>
                                <option value="x-per-week">X Times Per Week</option>
                                <option value="monthly-date">Monthly (Specific Date)</option>
                                <option value="monthly-relative">Monthly (Relative)</option>
                            </select>
                        </div>

                        <!-- Recurrence Configuration (shown based on pattern) -->
                        <div id="recurrence-config" style="display: none; background: #F5F5F5; padding: 12px; border-radius: 4px; margin-top: 8px;">
                            
                            <!-- Every X Days -->
                            <div id="config-every-x-days" style="display: none;">
                                <div class="form-group">
                                    <label>Repeat Every</label>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <input type="number" id="recurrence-interval" min="1" value="1" 
                                               onchange="app.updateRecurrenceConfig()" style="width: 60px;">
                                        <span>days</span>
                                    </div>
                                    <small style="color: #666; font-size: 9px; display: block; margin-top: 4px;">
                                        Example: 14 = Every 2 weeks
                                    </small>
                                </div>
                            </div>

                            <!-- Weekly Specific Days -->
                            <div id="config-weekly" style="display: none;">
                                <div class="form-group">
                                    <label>Days of Week</label>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px;">
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="mon" onchange="app.updateRecurrenceConfig()">
                                            <span>Mon</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="tue" onchange="app.updateRecurrenceConfig()">
                                            <span>Tue</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="wed" onchange="app.updateRecurrenceConfig()">
                                            <span>Wed</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="thu" onchange="app.updateRecurrenceConfig()">
                                            <span>Thu</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="fri" onchange="app.updateRecurrenceConfig()">
                                            <span>Fri</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="sat" onchange="app.updateRecurrenceConfig()">
                                            <span>Sat</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                            <input type="checkbox" class="weekday-check" value="sun" onchange="app.updateRecurrenceConfig()">
                                            <span>Sun</span>
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <!-- X Times Per Week -->
                            <div id="config-x-per-week" style="display: none;">
                                <div class="form-group">
                                    <label>Frequency</label>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <input type="number" id="recurrence-count" min="1" max="7" value="3" 
                                               onchange="app.updateRecurrenceConfig()" style="width: 60px;">
                                        <span>times per week</span>
                                    </div>
                                    <small style="color: #666; font-size: 9px; display: block; margin-top: 4px;">
                                        Flexible scheduling - complete any days you choose
                                    </small>
                                </div>
                            </div>

                            <!-- Monthly Specific Date -->
                            <div id="config-monthly-date" style="display: none;">
                                <div class="form-group">
                                    <label>Day of Month</label>
                                    <input type="number" id="recurrence-month-date" min="1" max="31" value="1" 
                                           onchange="app.updateRecurrenceConfig()" style="width: 80px;">
                                    <small style="color: #666; font-size: 9px; display: block; margin-top: 4px;">
                                        Example: 1 = 1st of each month, 15 = 15th of each month
                                    </small>
                                </div>
                            </div>

                            <!-- Monthly Relative -->
                            <div id="config-monthly-relative" style="display: none;">
                                <div class="form-group">
                                    <label>When in Month</label>
                                    <div style="display: flex; gap: 8px; margin-top: 4px;">
                                        <select id="recurrence-month-week" onchange="app.updateRecurrenceConfig()" style="flex: 1;">
                                            <option value="first">First</option>
                                            <option value="second">Second</option>
                                            <option value="third">Third</option>
                                            <option value="fourth">Fourth</option>
                                            <option value="last">Last</option>
                                        </select>
                                        <select id="recurrence-month-day" onchange="app.updateRecurrenceConfig()" style="flex: 1;">
                                            <option value="monday">Monday</option>
                                            <option value="tuesday">Tuesday</option>
                                            <option value="wednesday">Wednesday</option>
                                            <option value="thursday">Thursday</option>
                                            <option value="friday">Friday</option>
                                            <option value="saturday">Saturday</option>
                                            <option value="sunday">Sunday</option>
                                        </select>
                                    </div>
                                    <small style="color: #666; font-size: 9px; display: block; margin-top: 4px;">
                                        Example: "First Monday" or "Last Friday"
                                    </small>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Effort Tab -->
                    <div id="tab-effort" class="tab-panel" style="display: none;">
                        <div class="form-group">
                            <label>Estimated Effort (minutes)</label>
                            <input type="number" id="task-estimated-effort" min="0" 
                                   onchange="app.updateTaskEstimatedEffort()">
                        </div>

                        <div class="form-group">
                            <label>Actual Effort (minutes)</label>
                            <input type="number" id="task-actual-effort" min="0" 
                                   onchange="app.updateTaskActualEffort()">
                        </div>

                        <div class="form-group">
                            <p style="color: #666; font-size: 10px;">
                                Effort tracking helps calculate your actual life balance.
                                Estimated effort is used if actual is not entered.
                            </p>
                        </div>
                    </div>

                    <!-- Note Tab -->
                    <div id="tab-note" class="tab-panel" style="display: none;">
                        <div class="form-group">
                            <label>Notes</label>
                            <textarea id="task-note" onchange="app.updateTaskNote()"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // DATA MODEL
        // ============================================================================

        class Task {
            constructor(title, parentId = null) {
                this.id = Date.now() + Math.random();
                this.title = title;
                this.parentId = parentId;
                this.completed = false;
                this.completedAt = null;
                this.expanded = true;
                
                // Importance
                this.importance = 50;
                
                // Top-level only
                this.color = null;
                this.weight = null;
                
                // Location
                this.place = 'Anywhere';
                
                // Timing
                this.dueDate = null;
                this.dueTime = null;
                this.duration = null;
                this.startDate = null;
                this.leadTime = null;
                
                // Recurring
                this.recurrencePattern = 'none';
                this.recurrenceWeekdays = []; // For weekly: ['mon', 'wed', 'fri']
                this.recurrenceInterval = 1; // For "every X days/weeks/months"
                this.recurrenceCount = 1; // For "X times per week/month"
                this.recurrenceMonthDate = null; // For monthly: day of month (1-31)
                this.recurrenceMonthWeek = null; // For monthly: 'first', 'second', 'third', 'fourth', 'last'
                this.recurrenceMonthDay = null; // For monthly: 'monday', 'tuesday', etc.
                this.recurrenceCompletedThisPeriod = 0; // Track completions for X times per period
                
                // Effort
                this.estimatedEffort = 25;
                this.actualEffort = null;
                
                // Kanban status
                this.kanbanStatus = 'todo'; // 'todo', 'in-progress', or 'done'
                
                // Notes
                this.note = '';
                
                // Financial tracking
                this.financialValue = 0;
                
                // Pomodoro units (30-minute intervals)
                this.pomodoroUnits = 0; // Count of completed 30-minute units
            }

            getColor() {
                if (this.color) return this.color;
                if (this.parentId) {
                    const parent = app.findTask(this.parentId);
                    return parent ? parent.getColor() : 'blue';
                }
                return 'blue';
            }

            getRootAncestor() {
                if (!this.parentId) return this;
                const parent = app.findTask(this.parentId);
                return parent ? parent.getRootAncestor() : this;
            }

            getChildren() {
                return app.data.tasks.filter(t => t.parentId === this.id);
            }

            getAllDescendants() {
                const descendants = [];
                const children = this.getChildren();
                for (const child of children) {
                    descendants.push(child);
                    descendants.push(...child.getAllDescendants());
                }
                return descendants;
            }

            getImportanceCascade() {
                let cascade = this.importance / 100;
                if (this.parentId) {
                    const parent = app.findTask(this.parentId);
                    if (parent) {
                        cascade *= parent.getImportanceCascade();
                    }
                }
                return cascade;
            }
        }

        class Place {
            constructor(name) {
                this.id = Date.now() + Math.random();
                this.name = name;
                this.schedule = {};
                
                // Initialize all hours as closed (false)
                const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
                for (const day of days) {
                    this.schedule[day] = new Array(24).fill(false);
                }
            }

            isAvailableAt(date) {
                const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
                const day = days[date.getDay()];
                const hour = date.getHours();
                return this.schedule[day][hour] || false;
            }

            setAlwaysOpen() {
                const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
                for (const day of days) {
                    this.schedule[day] = new Array(24).fill(true);
                }
            }

            setWeekdayHours(start, end) {
                const weekdays = ['mon', 'tue', 'wed', 'thu', 'fri'];
                for (const day of weekdays) {
                    this.schedule[day] = new Array(24).fill(false);
                    for (let h = start; h < end; h++) {
                        this.schedule[day][h] = true;
                    }
                }
            }
        }

        class Envelope {
            constructor(name, color = '#2196F3') {
                this.id = Date.now() + Math.random();
                this.name = name;
                this.color = color;
                this.balance = 0;
            }
        }

        // ============================================================================
        // APPLICATION STATE
        // ============================================================================

        const app = {
            data: {
                tasks: [],
                places: [],
                envelopes: [],
                incomeEnvelope: { balance: 0 },
                expenses: [],
                dataLog: [],
                settings: {
                    currentView: 'outline',
                    currentTab: 'general',
                    selectedTaskId: null,
                    selectedPlaceId: null,
                    selectedEnvelopeId: null,
                    calendarMonth: new Date(),
                    calendarViewDate: new Date(), // For day calendar navigation
                    calendarViewMode: 'day' // 'day' or 'week'
                },
                sync: {
                    enabled: false,
                    token: null,
                    gistId: null,
                    lastSyncTime: null
                },
                taskTimers: {}, // taskId -> { startTime, elapsed, running }
                kanban: {
                    filter: 'all', // 'all' or life area task id
                    collapsedColumns: [], // Array of collapsed column ids
                    taskTimers: {} // taskId -> { startTime, elapsed }
                }
            },

            init() {
                this.loadData();
                this.initializePlaces();
                this.initializeSampleData();
                this.render();
                this.switchView(this.data.settings.currentView);
                
                // Request notification permissions for Pomodoro alerts
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }
                
                // Initialize keyboard shortcuts
                this.initKeyboardShortcuts();
                
                // Initialize interactive pie chart - do this AFTER render so canvas exists
                setTimeout(() => {
                    this.initializeInteractivePieChart();
                }, 100);
                
                // Initialize text drop for outline container
                this.initTextDropZone();
                
                // Click outside modal to close
                document.getElementById('day-detail-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'day-detail-modal') {
                        this.closeDayDetail();
                    }
                });
                
                // Update sync UI based on saved state
                this.updateSyncUI();
                if (this.data.sync.enabled) {
                    this.updateSyncStatus('‚úì Connected', '#4CAF50');
                    
                    // Auto-sync on startup
                    setTimeout(() => this.syncNow(), 1000);
                }
                
                // Update time display and check place availability every minute
                setInterval(() => {
                    this.updateCurrentTimeDisplay();
                    if (this.data.settings.currentView === 'todo') {
                        this.renderTodoList();
                    }
                }, 60000);
            },

            loadData() {
                const saved = localStorage.getItem('lifebalance-data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    this.data.tasks = parsed.tasks.map(t => Object.assign(new Task(), t));
                    this.data.places = parsed.places.map(p => Object.assign(new Place(), p));
                    
                    // Load envelopes
                    if (parsed.envelopes) {
                        this.data.envelopes = parsed.envelopes.map(e => Object.assign(new Envelope(), e));
                    }
                    
                    // Load income envelope
                    if (parsed.incomeEnvelope) {
                        this.data.incomeEnvelope = parsed.incomeEnvelope;
                    }
                    
                    // Load expenses
                    if (parsed.expenses) {
                        this.data.expenses = parsed.expenses;
                    }
                    
                    // Load data log
                    if (parsed.dataLog) {
                        this.data.dataLog = parsed.dataLog;
                    }
                    
                    if (parsed.settings) {
                        this.data.settings = { ...this.data.settings, ...parsed.settings };
                        this.data.settings.calendarMonth = new Date(parsed.settings.calendarMonth);
                    }
                    if (parsed.sync) {
                        this.data.sync = { ...this.data.sync, ...parsed.sync };
                    }
                    if (parsed.pomodoro) {
                        this.data.pomodoro = { ...this.data.pomodoro, ...parsed.pomodoro };
                    }
                    if (parsed.kanban) {
                        this.data.kanban = { ...this.data.kanban, ...parsed.kanban };
                    }
                    if (parsed.taskTimers) {
                        this.data.taskTimers = parsed.taskTimers;
                    } else {
                        // Initialize taskTimers if it doesn't exist in saved data
                        this.data.taskTimers = {};
                    }
                    
                    // Convert task completion dates back to Date objects
                    this.data.tasks.forEach(task => {
                        if (task.completedAt) {
                            task.completedAt = new Date(task.completedAt);
                        }
                        // Ensure kanbanStatus exists on all tasks
                        if (!task.kanbanStatus) {
                            task.kanbanStatus = 'todo';
                        }
                        // Ensure financialValue exists on all tasks
                        if (task.financialValue === undefined) {
                            task.financialValue = 0;
                        }
                    });
                }
            },

            saveData() {
                localStorage.setItem('lifebalance-data', JSON.stringify(this.data));
                
                // Auto-sync if enabled
                if (this.data.sync.enabled && !this.syncing) {
                    clearTimeout(this.syncTimeout);
                    this.syncTimeout = setTimeout(() => this.syncNow(), 2000);
                }
            },

            // ============================================================================
            // POMODORO TIMER
            // ============================================================================

            initializePlaces() {
                if (this.data.places.length === 0) {
                    // Anywhere - always open
                    const anywhere = new Place('Anywhere');
                    anywhere.setAlwaysOpen();
                    this.data.places.push(anywhere);

                    // Home - always open
                    const home = new Place('Home');
                    home.setAlwaysOpen();
                    this.data.places.push(home);

                    // Work - weekdays 9-5
                    const work = new Place('Work');
                    work.setWeekdayHours(9, 17);
                    this.data.places.push(work);

                    // Computer - weekdays 9-5
                    const computer = new Place('Computer');
                    computer.setWeekdayHours(9, 17);
                    this.data.places.push(computer);

                    // Phone - weekdays 9-9, weekends 10-6
                    const phone = new Place('Phone');
                    phone.setWeekdayHours(9, 21);
                    ['sat', 'sun'].forEach(day => {
                        phone.schedule[day] = new Array(24).fill(false);
                        for (let h = 10; h < 18; h++) {
                            phone.schedule[day][h] = true;
                        }
                    });
                    this.data.places.push(phone);

                    // Errands - all days 9-9, except Sunday 10-6
                    const errands = new Place('Errands');
                    ['mon', 'tue', 'wed', 'thu', 'fri', 'sat'].forEach(day => {
                        errands.schedule[day] = new Array(24).fill(false);
                        for (let h = 9; h < 21; h++) {
                            errands.schedule[day][h] = true;
                        }
                    });
                    errands.schedule.sun = new Array(24).fill(false);
                    for (let h = 10; h < 18; h++) {
                        errands.schedule.sun[h] = true;
                    }
                    this.data.places.push(errands);

                    this.saveData();
                }
            },

            initializeSampleData() {
                if (this.data.tasks.length === 0) {
                    // Create sample top-level tasks (life areas)
                    const selfCare = new Task('Take care of myself');
                    selfCare.color = 'red';
                    selfCare.weight = 20;
                    selfCare.importance = 80;
                    this.data.tasks.push(selfCare);

                    const work = new Task('Earn a living');
                    work.color = 'green';
                    work.weight = 25;
                    work.importance = 80;
                    this.data.tasks.push(work);

                    const organized = new Task('Keep life organized');
                    organized.color = 'yellow';
                    organized.weight = 15;
                    organized.importance = 70;
                    this.data.tasks.push(organized);

                    const family = new Task('Interact with family and friends');
                    family.color = 'blue';
                    family.weight = 25;
                    family.importance = 80;
                    this.data.tasks.push(family);

                    const relax = new Task('Relax and enjoy life');
                    relax.color = 'purple';
                    relax.weight = 15;
                    relax.importance = 70;
                    this.data.tasks.push(relax);

                    // Add some sample subtasks
                    const gym = new Task('Go to gym', selfCare.id);
                    gym.importance = 70;
                    gym.place = 'Anywhere';
                    gym.estimatedEffort = 60;
                    this.data.tasks.push(gym);

                    const meeting = new Task('Team meeting', work.id);
                    meeting.importance = 80;
                    meeting.place = 'Work';
                    meeting.estimatedEffort = 60;
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const day = String(now.getDate()).padStart(2, '0');
                    meeting.dueDate = `${year}-${month}-${day}`;
                    this.data.tasks.push(meeting);

                    const grocery = new Task('Buy groceries', organized.id);
                    grocery.importance = 60;
                    grocery.place = 'Errands';
                    grocery.estimatedEffort = 45;
                    this.data.tasks.push(grocery);

                    const callMom = new Task('Call mom', family.id);
                    callMom.importance = 70;
                    callMom.place = 'Phone';
                    callMom.estimatedEffort = 30;
                    this.data.tasks.push(callMom);

                    const readBook = new Task('Read book', relax.id);
                    readBook.importance = 60;
                    readBook.place = 'Anywhere';
                    readBook.estimatedEffort = 45;
                    this.data.tasks.push(readBook);

                    this.saveData();
                }
            },

            findTask(id) {
                return this.data.tasks.find(t => t.id === id);
            },

            findPlace(name) {
                return this.data.places.find(p => p.name === name);
            },

            // ============================================================================
            // GITHUB GIST SYNC
            // ============================================================================

            setupGistSync() {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    font-family: 'Segoe UI', Tahoma, sans-serif;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 8px; max-width: 600px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                        <h2 style="margin: 0 0 20px 0; font-size: 18px; color: #333;">üîß Setup GitHub Gist Sync</h2>
                        
                        <div style="background: #FFF3CD; border: 1px solid #FFC107; padding: 12px; border-radius: 4px; margin-bottom: 20px; font-size: 12px;">
                            <strong>üìã Quick Setup (2 minutes):</strong><br>
                            1. Go to github.com/settings/tokens<br>
                            2. Click "Generate new token (classic)"<br>
                            3. Give it a name: "LifeBalance Sync"<br>
                            4. Check only: <strong>gist</strong> permission<br>
                            5. Generate token and copy it<br>
                            6. Paste below üëá
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 12px;">
                                GitHub Personal Access Token:
                            </label>
                            <input type="password" id="gist-token-input" 
                                   placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                                   style="width: 100%; padding: 10px; border: 1px solid #CCC; border-radius: 4px; font-size: 13px; font-family: monospace;">
                            <small style="color: #666; font-size: 10px; display: block; margin-top: 4px;">
                                ‚úì Stored locally in your browser<br>
                                ‚úì Only used to sync with YOUR private gist<br>
                                ‚úì Never shared with anyone
                            </small>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button onclick="window.open('https://github.com/settings/tokens/new', '_blank')" 
                                    style="padding: 10px 20px; background: #24292e; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                üîó Open GitHub
                            </button>
                            <button onclick="this.closest('[style]').remove()" 
                                    style="padding: 10px 20px; background: #999; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                Cancel
                            </button>
                            <button onclick="app.saveGistToken(document.getElementById('gist-token-input').value); this.closest('[style]').remove();" 
                                    style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                üíæ Save & Connect
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Close on background click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('gist-token-input').focus();
                }, 100);
            },

            async saveGistToken(token) {
                if (!token || !token.startsWith('ghp_')) {
                    alert('‚ùå Invalid token! GitHub tokens start with "ghp_"');
                    return;
                }
                
                this.data.sync.token = token;
                this.data.sync.enabled = true;
                this.saveData();
                this.updateSyncUI();
                
                // Initial sync
                await this.syncNow();
                
                this.showToast('‚úÖ Connected to GitHub Gist!\nüîÑ Auto-sync enabled');
            },

            disconnectGist() {
                if (confirm('Disconnect from GitHub Gist? Your data will remain on this device.')) {
                    this.data.sync.enabled = false;
                    this.data.sync.token = null;
                    this.data.sync.gistId = null;
                    this.saveData();
                    this.updateSyncUI();
                    this.updateSyncStatus('Disconnected');
                }
            },

            async syncNow() {
                if (!this.data.sync.enabled || !this.data.sync.token) {
                    this.showToast('‚ö†Ô∏è Please setup GitHub Gist sync first');
                    return;
                }

                if (this.syncing) return;
                this.syncing = true;

                try {
                    this.updateSyncStatus('Syncing...', '#2196F3');
                    
                    if (!this.data.sync.gistId) {
                        // First sync - create gist
                        await this.createGist();
                        this.updateSyncStatus('‚úì Synced (new)', '#4CAF50');
                    } else {
                        // Check which is newer
                        const cloudData = await this.downloadGist();
                        
                        if (cloudData) {
                            const localTime = this.data.sync.lastSyncTime || 0;
                            const cloudTime = cloudData.sync?.lastSyncTime || 0;
                            
                            if (cloudTime > localTime) {
                                // Cloud is newer
                                this.mergeCloudData(cloudData);
                                this.updateSyncStatus('‚úì Synced ‚Üì', '#4CAF50');
                            } else if (localTime > cloudTime) {
                                // Local is newer
                                await this.updateGist();
                                this.updateSyncStatus('‚úì Synced ‚Üë', '#4CAF50');
                            } else {
                                this.updateSyncStatus('‚úì Up to date', '#4CAF50');
                            }
                        }
                    }
                    
                    this.data.sync.lastSyncTime = Date.now();
                    this.saveData();
                    
                } catch (err) {
                    console.error('Sync error:', err);
                    this.updateSyncStatus('‚ö† Sync failed', '#FF5722');
                    
                    if (err.message.includes('401')) {
                        this.showToast('‚ùå Invalid token! Please reconnect.');
                        this.data.sync.enabled = false;
                        this.updateSyncUI();
                    }
                } finally {
                    this.syncing = false;
                }
            },

            async createGist() {
                const data = JSON.stringify(this.data, null, 2);
                
                const response = await fetch('https://api.github.com/gists', {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${this.data.sync.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        description: 'LifeBalance App Data',
                        public: false,
                        files: {
                            'lifebalance-data.json': {
                                content: data
                            }
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to create gist: ${response.status}`);
                }

                const result = await response.json();
                this.data.sync.gistId = result.id;
            },

            async updateGist() {
                const data = JSON.stringify(this.data, null, 2);
                
                const response = await fetch(`https://api.github.com/gists/${this.data.sync.gistId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `token ${this.data.sync.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: {
                            'lifebalance-data.json': {
                                content: data
                            }
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to update gist: ${response.status}`);
                }
            },

            async downloadGist() {
                const response = await fetch(`https://api.github.com/gists/${this.data.sync.gistId}`, {
                    headers: {
                        'Authorization': `token ${this.data.sync.token}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 404) {
                        this.data.sync.gistId = null;
                        return null;
                    }
                    throw new Error(`Failed to download gist: ${response.status}`);
                }

                const result = await response.json();
                const content = result.files['lifebalance-data.json'].content;
                return JSON.parse(content);
            },

            mergeCloudData(cloudData) {
                // Smart merge: keep most recent version of each task
                const merged = {
                    tasks: [],
                    places: cloudData.places || this.data.places,
                    settings: { ...this.data.settings, ...cloudData.settings },
                    sync: { ...this.data.sync, lastSyncTime: cloudData.sync?.lastSyncTime }
                };

                const localTasksMap = new Map();
                this.data.tasks.forEach(task => {
                    localTasksMap.set(task.id, task);
                });

                cloudData.tasks.forEach(cloudTask => {
                    const localTask = localTasksMap.get(cloudTask.id);
                    
                    if (!localTask) {
                        merged.tasks.push(Object.assign(new Task(), cloudTask));
                    } else {
                        const cloudTime = cloudTask.completedAt ? new Date(cloudTask.completedAt).getTime() : 0;
                        const localTime = localTask.completedAt ? new Date(localTask.completedAt).getTime() : 0;
                        
                        if (cloudTime > localTime) {
                            merged.tasks.push(Object.assign(new Task(), cloudTask));
                        } else {
                            merged.tasks.push(localTask);
                        }
                        
                        localTasksMap.delete(cloudTask.id);
                    }
                });

                localTasksMap.forEach(task => {
                    merged.tasks.push(task);
                });

                this.data = merged;
                
                if (this.data.settings.calendarMonth) {
                    this.data.settings.calendarMonth = new Date(this.data.settings.calendarMonth);
                }
                
                this.data.tasks.forEach(task => {
                    if (task.completedAt) {
                        task.completedAt = new Date(task.completedAt);
                    }
                });
                
                this.saveData();
                this.render();
            },

            updateSyncUI() {
                const setupBtn = document.getElementById('btn-setup-gist');
                const syncBtn = document.getElementById('btn-sync');
                const disconnectBtn = document.getElementById('btn-disconnect');

                if (this.data.sync.enabled) {
                    setupBtn.style.display = 'none';
                    syncBtn.style.display = 'inline-block';
                    disconnectBtn.style.display = 'inline-block';
                } else {
                    setupBtn.style.display = 'inline-block';
                    syncBtn.style.display = 'none';
                    disconnectBtn.style.display = 'none';
                }
            },

            updateSyncStatus(message, color = '#666') {
                const statusText = document.getElementById('sync-status-text');
                if (statusText) {
                    statusText.textContent = message;
                    statusText.style.color = color;
                }
            },

            // ============================================================================
            // PREPLY LESSONS IMPORT (SIMPLE VERSION)
            // ============================================================================

            importPreplyLessons() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,.ics';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            let lessons = [];
                            
                            // Try to parse as JSON
                            const data = JSON.parse(content);
                            
                            // Try multiple formats
                            if (data.lessons && Array.isArray(data.lessons)) {
                                // Format 1: { lessons: [...] }
                                lessons = data.lessons;
                            } else if (Array.isArray(data)) {
                                // Format 2: Just an array of lessons
                                lessons = data;
                            } else if (data.items && Array.isArray(data.items)) {
                                // Format 3: Google Calendar export { items: [...] }
                                lessons = data.items.map(item => ({
                                    student: item.summary || item.title || 'Unknown',
                                    date: item.start?.date || item.start?.dateTime?.split('T')[0],
                                    time: item.start?.dateTime?.split('T')[1]?.substring(0, 5),
                                    duration: this.calculateDuration(item.start?.dateTime, item.end?.dateTime),
                                    link: item.htmlLink || item.hangoutLink
                                }));
                            } else if (data.events && Array.isArray(data.events)) {
                                // Format 4: { events: [...] }
                                lessons = data.events.map(event => ({
                                    student: event.summary || event.title || event.name || 'Unknown',
                                    date: event.date || event.start_date || event.start?.split('T')[0],
                                    time: event.time || event.start_time || event.start?.split('T')[1]?.substring(0, 5),
                                    duration: event.duration || 50,
                                    link: event.link || event.url
                                }));
                            } else {
                                // Format 5: Single lesson object
                                lessons = [data];
                            }

                            if (lessons.length === 0) {
                                alert('‚ùå No lessons found in file!');
                                return;
                            }

                            // Ensure parent task structure
                            const earnALivingTask = this.ensureEarnALivingTask();
                            const preplyParentTask = this.ensurePreplyParentTask(earnALivingTask.id);

                            // Import each lesson
                            let imported = 0;
                            let skipped = 0;
                            
                            lessons.forEach(lesson => {
                                // Normalize lesson format
                                const normalizedLesson = {
                                    student: lesson.student || lesson.summary || lesson.title || lesson.name || 'Unknown Student',
                                    date: lesson.date || lesson.start_date || lesson.start?.split('T')[0],
                                    time: lesson.time || lesson.start_time || lesson.start?.split('T')[1]?.substring(0, 5),
                                    duration: lesson.duration || 50,
                                    link: lesson.link || lesson.url || lesson.htmlLink
                                };
                                
                                if (normalizedLesson.date && normalizedLesson.time) {
                                    const result = this.createPreplyTask(normalizedLesson, preplyParentTask.id);
                                    if (result === 'created') {
                                        imported++;
                                    } else if (result === 'skipped') {
                                        skipped++;
                                    }
                                }
                            });

                            this.saveData();
                            this.render();

                            let message = `‚úÖ Imported ${imported} Preply lessons!`;
                            if (skipped > 0) {
                                message += ` (${skipped} duplicates skipped)`;
                            }
                            alert(message);

                        } catch (err) {
                            alert('‚ùå Error importing: ' + err.message + '\n\nPlease share your file format so I can fix this!');
                            console.error('Import error:', err);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            },

            calculateDuration(startTime, endTime) {
                if (!startTime || !endTime) return 50;
                const start = new Date(startTime);
                const end = new Date(endTime);
                return Math.round((end - start) / 60000); // Convert to minutes
            },

            createPreplyTask(lesson, parentId) {
                // Check if task already exists (by student name and date/time)
                const existingTask = this.data.tasks.find(t => 
                    t.parentId === parentId &&
                    t.title.includes(lesson.student) &&
                    t.dueDate === lesson.date &&
                    t.dueTime === lesson.time
                );

                if (existingTask) {
                    return 'skipped'; // Skip duplicates
                }

                // Create new task
                const task = new Task(`${lesson.student} - Preply lesson`, parentId);
                task.dueDate = lesson.date;
                task.dueTime = lesson.time;
                task.duration = lesson.duration || 50;
                task.estimatedEffort = lesson.duration || 50;
                task.importance = 65;
                task.place = 'Computer';
                
                if (lesson.link) {
                    task.note = `Preply Classroom: ${lesson.link}`;
                }

                this.data.tasks.push(task);
                return 'created';
            },

            ensureEarnALivingTask() {
                // Find or create "Earn a Living" top-level task
                let earnALiving = this.data.tasks.find(t => 
                    t.parentId === null && 
                    t.title.toLowerCase().includes('earn') && 
                    t.title.toLowerCase().includes('living')
                );

                if (!earnALiving) {
                    earnALiving = new Task('Earn a Living', null);
                    earnALiving.color = 'green';
                    earnALiving.weight = 25;
                    earnALiving.importance = 60;
                    this.data.tasks.push(earnALiving);
                    this.saveData();
                }

                return earnALiving;
            },

            ensurePreplyParentTask(parentId) {
                // Find or create "Preply Teaching" subtask
                let preplyParent = this.data.tasks.find(t => 
                    t.parentId === parentId && 
                    t.title.toLowerCase().includes('preply')
                );

                if (!preplyParent) {
                    preplyParent = new Task('Preply Teaching', parentId);
                    preplyParent.importance = 70;
                    preplyParent.place = 'Computer';
                    preplyParent.note = 'Teaching lessons imported from calendar';
                    this.data.tasks.push(preplyParent);
                    this.saveData();
                }

                return preplyParent;
            },

            // ============================================================================
            // FUZZY LOGIC PRIORITY ALGORITHM
            // ============================================================================

            calculatePriority(task) {
                let score = 0;

                // 1. IMPORTANCE CASCADE (weighted 30x)
                const importance = task.getImportanceCascade();
                score += importance * 30;

                // 2. BALANCE DEFICIT (0-100 boost)
                const balanceBoost = this.calculateBalanceDeficit(task);
                score += balanceBoost;

                // 3. URGENCY (0-50 points)
                const urgency = this.calculateUrgency(task);
                score += urgency;

                // 4. PLACE RELEVANCE (bonus if available now)
                const placeBoost = this.calculatePlaceBoost(task);
                score += placeBoost;

                return score;
            },

            calculateBalanceDeficit(task) {
                const root = task.getRootAncestor();
                if (!root.weight) return 0;

                const desired = root.weight / 100;
                const actual = this.getActualTimeThisWeek(root.id);
                const deficit = Math.max(0, desired - actual);

                // Multiply by 100 (original LifeBalance formula)
                // Provides gentle but consistent nudge toward balance
                return deficit * 100;
            },

            getActualTimeThisWeek(rootTaskId) {
                const weekStart = this.getStartOfWeek(new Date());
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekEnd.getDate() + 7);
                const now = new Date();

                let totalMinutes = 0;
                let areaMinutes = 0;

                const root = this.findTask(rootTaskId);
                const descendants = root.getAllDescendants().map(t => t.id);
                descendants.push(rootTaskId);

                this.data.tasks.forEach(task => {
                    let shouldCount = false;
                    let eventDate = null;
                    
                    // Check if task is manually completed
                    if (task.completed && task.completedAt) {
                        eventDate = new Date(task.completedAt);
                        shouldCount = true;
                    }
                    // Check if task is a timed event that has already occurred
                    else if (task.dueDate && task.dueTime && task.duration) {
                        const taskDateTime = new Date(task.dueDate + 'T' + task.dueTime);
                        const taskEndTime = new Date(taskDateTime.getTime() + task.duration * 60000);
                        
                        // If the timed event has finished, count it
                        if (taskEndTime <= now) {
                            eventDate = taskDateTime;
                            shouldCount = true;
                        }
                    }
                    
                    // If we should count this task and it's in the current week
                    if (shouldCount && eventDate && eventDate >= weekStart && eventDate < weekEnd) {
                        const effort = task.actualEffort || task.estimatedEffort || task.duration || 25;
                        totalMinutes += effort;

                        if (descendants.includes(task.id)) {
                            areaMinutes += effort;
                        }
                    }
                });

                return totalMinutes > 0 ? areaMinutes / totalMinutes : 0;
            },

            getStartOfWeek(date) {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day;
                return new Date(d.setDate(diff));
            },

            calculateUrgency(task) {
                if (!task.dueDate) return 0;

                // For timed tasks, calculate urgency based on minutes until the event
                if (task.dueTime) {
                    const now = new Date();
                    const taskDateTime = new Date(task.dueDate + 'T' + task.dueTime);
                    const minutesUntil = (taskDateTime - now) / (1000 * 60);
                    
                    // If the event has already passed, deprioritize it
                    if (minutesUntil < 0) return -20;
                    
                    // Strong but balanced urgency for timed events
                    // These values will push timed tasks near the top but won't completely
                    // override importance hierarchy and balance deficits
                    if (minutesUntil < 15) return 90;       // Within 15 minutes: very urgent
                    if (minutesUntil < 30) return 85;       // Within 30 minutes
                    if (minutesUntil < 60) return 80;       // Within 1 hour
                    if (minutesUntil < 120) return 75;      // Within 2 hours
                    if (minutesUntil < 240) return 70;      // Within 4 hours
                    if (minutesUntil < 480) return 65;      // Within 8 hours (same day)
                    if (minutesUntil < 1440) return 60;     // Within 24 hours (today/tomorrow)
                    if (minutesUntil < 2880) return 55;     // Within 2 days
                    
                    // For timed events further out, fall through to date-based calculation
                }

                // Date-based urgency for non-timed tasks
                const now = new Date();
                now.setHours(0, 0, 0, 0);
                const due = new Date(task.dueDate);
                due.setHours(0, 0, 0, 0);
                const daysUntil = Math.floor((due - now) / (1000 * 60 * 60 * 24));

                if (task.leadTime && daysUntil > task.leadTime) {
                    return 0;
                }

                if (daysUntil < 0) return 50;
                if (daysUntil === 0) return 40;
                if (daysUntil === 1) return 30;
                if (daysUntil < 7) {
                    return 20 - (daysUntil * 2.5);
                }
                if (daysUntil < 30) {
                    return 10 * (30 - daysUntil) / 30;
                }

                return 0;
            },

            calculatePlaceBoost(task) {
                const now = new Date();
                
                if (task.place === 'Anywhere') return 5;

                const place = this.findPlace(task.place);
                if (!place) return 0;

                const isOpen = place.isAvailableAt(now);
                return isOpen ? 10 : -20;
            },

            // ============================================================================
            // BALANCE CALCULATION
            // ============================================================================

            calculateBalance() {
                const weekStart = this.getStartOfWeek(new Date());
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekEnd.getDate() + 7);
                const now = new Date();

                const topLevelTasks = this.data.tasks.filter(t => !t.parentId && t.weight);
                
                const desired = {};
                const actual = {};
                const effortByArea = {};
                let totalEffort = 0;

                topLevelTasks.forEach(task => {
                    desired[task.id] = task.weight;
                    effortByArea[task.id] = 0;
                });

                this.data.tasks.forEach(task => {
                    let shouldCount = false;
                    let eventDate = null;
                    
                    // Check if task is manually completed
                    if (task.completed && task.completedAt) {
                        eventDate = new Date(task.completedAt);
                        shouldCount = true;
                    }
                    // Check if task is a timed event that has already occurred
                    else if (task.dueDate && task.dueTime && task.duration) {
                        const taskDateTime = new Date(task.dueDate + 'T' + task.dueTime);
                        const taskEndTime = new Date(taskDateTime.getTime() + task.duration * 60000);
                        
                        // If the timed event has finished, count it
                        if (taskEndTime <= now) {
                            eventDate = taskDateTime;
                            shouldCount = true;
                        }
                    }
                    
                    // If we should count this task and it's in the current week
                    if (shouldCount && eventDate && eventDate >= weekStart && eventDate < weekEnd) {
                        const effort = task.actualEffort || task.estimatedEffort || task.duration || 25;
                        totalEffort += effort;

                        const root = task.getRootAncestor();
                        if (root.weight !== null && effortByArea[root.id] !== undefined) {
                            effortByArea[root.id] += effort;
                        }
                    }
                });

                topLevelTasks.forEach(task => {
                    if (totalEffort > 0) {
                        actual[task.id] = Math.round((effortByArea[task.id] / totalEffort) * 100);
                    } else {
                        actual[task.id] = 0;
                    }
                });

                return { desired, actual, topLevelTasks };
            },

            // ============================================================================
            // UI RENDERING
            // ============================================================================

            render() {
                this.renderOutline();
                this.renderTodoList();
                this.renderPlaces();
                this.renderBalance();
                this.renderTaskDetail();
                this.renderMiniCalendar();
                this.updatePlaceFilters();
            },

            switchView(view) {
                this.data.settings.currentView = view;
                
                // Update body class for view-specific styling
                document.body.className = `view-${view}`;
                
                document.querySelectorAll('.toolbar button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`btn-${view}`).classList.add('active');

                document.querySelectorAll('.view-content').forEach(v => {
                    v.style.display = 'none';
                });
                document.getElementById(`${view}-view`).style.display = 
                    view === 'todo' ? 'flex' : 
                    view === 'places' ? 'flex' : 
                    view === 'balance' ? 'flex' :
                    view === 'day-calendar' ? 'block' :
                    view === 'envelopes' ? 'block' :
                    view === 'datalog' ? 'block' : 'block';

                // Hide left-pane and right-pane for full-width views
                const leftPane = document.querySelector('.left-pane');
                const rightPane = document.querySelector('.right-pane');
                
                if (view === 'places' || view === 'balance' || view === 'todo' || view === 'day-calendar' || view === 'envelopes' || view === 'datalog') {
                    leftPane.style.display = 'none';
                    rightPane.style.display = 'none';
                } else {
                    leftPane.style.display = 'flex';
                    rightPane.style.display = 'flex';
                }
                
                // Render day calendar if switching to it
                if (view === 'day-calendar') {
                    this.renderDayCalendar();
                }
                
                // Render envelopes view if switching to it
                if (view === 'envelopes') {
                    this.renderEnvelopesView();
                    this.renderExpenseHistory();
                    this.updateExpenseDropdowns();
                    // Set today's date as default for expense form
                    const expenseDateField = document.getElementById('expense-date');
                    if (expenseDateField && !expenseDateField.value) {
                        expenseDateField.valueAsDate = new Date();
                    }
                }
                
                // Render data log view if switching to it
                if (view === 'datalog') {
                    this.renderDataLog();
                    // Set today's date as default
                    document.getElementById('log-date').valueAsDate = new Date();
                }

                this.saveData();
            },

            switchTab(tab) {
                this.data.settings.currentTab = tab;
                
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tab}"]`).classList.add('active');

                document.querySelectorAll('.tab-panel').forEach(p => {
                    p.style.display = 'none';
                });
                document.getElementById(`tab-${tab}`).style.display = 'block';

                this.saveData();
            },

            renderOutline() {
                const container = document.getElementById('outline-container');
                container.innerHTML = '';

                const topLevelTasks = this.data.tasks.filter(t => !t.parentId);
                topLevelTasks.forEach(task => {
                    this.renderTaskItem(task, container, 0);
                });
            },

            renderTaskItem(task, container, depth) {
                const div = document.createElement('div');
                div.className = 'task-item' + 
                    (task.completed ? ' completed' : '') +
                    (this.data.settings.selectedTaskId === task.id ? ' selected' : '');
                // Use margin-left for indentation to avoid CSS padding conflicts
                div.style.marginLeft = (depth * 20) + 'px';
                div.onclick = () => this.selectTask(task.id);
                
                // Remove draggable from div - only drag handle will be draggable
                div.dataset.taskId = task.id;
                
                // Keep drag handlers on div for drop target functionality
                div.ondragover = (e) => this.handleDragOver(e);
                div.ondragenter = (e) => this.handleDragEnter(e);
                div.ondragleave = (e) => this.handleDragLeave(e);
                div.ondrop = (e) => this.handleDrop(e, task);

                const dragHandle = document.createElement('span');
                dragHandle.className = 'drag-handle';
                dragHandle.textContent = '‚ãÆ‚ãÆ';
                dragHandle.title = 'Drag to reorder or move';
                
                // Make ONLY the drag handle draggable
                dragHandle.draggable = true;
                dragHandle.ondragstart = (e) => {
                    // Set the parent div as dragging for visual feedback
                    div.classList.add('dragging');
                    this.handleDragStart(e, task);
                };
                dragHandle.ondragend = (e) => {
                    div.classList.remove('dragging');
                    this.handleDragEnd(e);
                };
                
                div.appendChild(dragHandle);

                const children = task.getChildren();
                const expander = document.createElement('span');
                expander.className = 'expander';
                if (children.length > 0) {
                    expander.textContent = task.expanded ? '‚ñº' : '‚ñ∂';
                    expander.onclick = (e) => {
                        e.stopPropagation();
                        task.expanded = !task.expanded;
                        this.saveData();
                        this.renderOutline();
                    };
                } else {
                    expander.textContent = '  ';
                }
                div.appendChild(expander);

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'checkbox';
                checkbox.checked = task.completed;
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    this.toggleTaskCompletion(task.id);
                };
                div.appendChild(checkbox);

                const bullet = document.createElement('div');
                bullet.className = 'task-bullet color-' + task.getColor();
                div.appendChild(bullet);

                const title = document.createElement('span');
                title.className = 'task-title';
                title.textContent = task.title;
                
                if (task.recurrencePattern !== 'none') {
                    const recurIcon = document.createElement('span');
                    recurIcon.textContent = ' üîÑ';
                    recurIcon.title = this.getRecurrenceDescription(task);
                    recurIcon.style.fontSize = '10px';
                    title.appendChild(recurIcon);
                }
                
                div.appendChild(title);

                if (task.dueDate && !task.completed) {
                    const badge = document.createElement('span');
                    badge.className = 'task-due-date';
                    
                    const now = new Date();
                    now.setHours(0, 0, 0, 0);
                    const due = new Date(task.dueDate);
                    due.setHours(0, 0, 0, 0);
                    const daysUntil = Math.floor((due - now) / (1000 * 60 * 60 * 24));
                    
                    if (daysUntil < 0) {
                        badge.textContent = 'overdue';
                        badge.classList.add('due-overdue');
                    } else if (daysUntil === 0) {
                        badge.textContent = 'today';
                        badge.classList.add('due-today');
                    } else if (daysUntil === 1) {
                        badge.textContent = 'tomorrow';
                        badge.classList.add('due-tomorrow');
                    } else {
                        badge.textContent = task.dueDate;
                    }
                    div.appendChild(badge);
                }

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '√ó';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    this.deleteTask(task.id);
                };
                div.appendChild(deleteBtn);

                container.appendChild(div);

                if (task.expanded && children.length > 0) {
                    children.forEach(child => {
                        this.renderTaskItem(child, container, depth + 1);
                    });
                }
            },

            renderTodoList() {
                const container = document.getElementById('todo-cards-grid');
                container.innerHTML = '';
                
                this.updateCurrentTimeDisplay();

                const incompleteTasks = this.data.tasks.filter(t => {
                    if (t.completed) return false;
                    
                    const children = t.getChildren();
                    if (children.length > 0) return false;
                    
                    if (t.startDate) {
                        const now = new Date();
                        now.setHours(0, 0, 0, 0);
                        const start = new Date(t.startDate + 'T00:00:00');
                        start.setHours(0, 0, 0, 0);
                        if (now < start) {
                            return false;
                        }
                    }
                    
                    if (t.dueDate) {
                        const now = new Date();
                        now.setHours(0, 0, 0, 0);
                        const due = new Date(t.dueDate + 'T00:00:00');
                        due.setHours(0, 0, 0, 0);
                        const daysUntil = Math.floor((due - now) / (1000 * 60 * 60 * 24));
                        
                        if (daysUntil > 0) {
                            const leadTime = t.leadTime || 0;
                            
                            if (daysUntil > leadTime) {
                                return false;
                            }
                        }
                    }
                    
                    return true;
                });

                const tasksWithPriority = incompleteTasks.map(task => ({
                    task,
                    priority: this.calculatePriority(task)
                }));

                tasksWithPriority.sort((a, b) => b.priority - a.priority);

                const placeFilter = document.getElementById('place-filter').value;
                const includeClosed = document.getElementById('include-closed').checked;
                const now = new Date();

                const filtered = tasksWithPriority.filter(({ task }) => {
                    if (placeFilter !== 'all' && task.place !== placeFilter) {
                        return false;
                    }

                    if (!includeClosed && task.place !== 'Anywhere') {
                        const place = this.findPlace(task.place);
                        if (place && !place.isAvailableAt(now)) {
                            return false;
                        }
                    }

                    return true;
                });

                filtered.forEach(({ task, priority }) => {
                    const card = document.createElement('div');
                    card.className = 'todo-card' + (task.completed ? ' completed' : '');
                    card.style.borderLeftColor = this.getColorHex(task.getColor());
                    card.onclick = () => {
                        this.selectTask(task.id);
                        this.switchView('outline');
                    };

                    // Card Header with checkbox, priority, and content
                    const header = document.createElement('div');
                    header.className = 'todo-card-header';

                    // Checkbox
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'todo-card-checkbox';
                    checkbox.checked = task.completed;
                    checkbox.onclick = (e) => {
                        e.stopPropagation();
                        this.toggleTaskCompletion(task.id);
                    };
                    header.appendChild(checkbox);

                    // Content section
                    const content = document.createElement('div');
                    content.className = 'todo-card-content';

                    // Title
                    const title = document.createElement('div');
                    title.className = 'todo-card-title';
                    title.textContent = task.title;
                    
                    if (task.recurrencePattern !== 'none') {
                        const recurIcon = document.createElement('span');
                        recurIcon.textContent = ' üîÑ';
                        recurIcon.title = this.getRecurrenceDescription(task);
                        recurIcon.style.fontSize = '12px';
                        title.appendChild(recurIcon);
                    }
                    content.appendChild(title);

                    // Parent context
                    const parent = this.findTask(task.parentId);
                    if (parent) {
                        const parentDiv = document.createElement('div');
                        parentDiv.className = 'todo-card-parent';
                        parentDiv.textContent = 'üìÇ ' + parent.title;
                        content.appendChild(parentDiv);
                    }

                    // Metadata badges
                    const meta = document.createElement('div');
                    meta.className = 'todo-card-meta';

                    // Time badge
                    if (task.dueTime) {
                        const timeBadge = document.createElement('div');
                        timeBadge.className = 'todo-card-badge time';
                        timeBadge.textContent = 'üïê ' + task.dueTime;
                        meta.appendChild(timeBadge);
                    }

                    // Place badge
                    if (task.place && task.place !== 'Anywhere') {
                        const placeBadge = document.createElement('div');
                        placeBadge.className = 'todo-card-badge place';
                        const place = this.findPlace(task.place);
                        const isOpen = place && place.isAvailableAt(now);
                        placeBadge.textContent = (isOpen ? 'üü¢' : 'üî¥') + ' ' + task.place;
                        if (!isOpen) {
                            placeBadge.style.background = '#FFEBEE';
                            placeBadge.style.color = '#C62828';
                        }
                        meta.appendChild(placeBadge);
                    }

                    // Duration badge
                    if (task.duration) {
                        const durationBadge = document.createElement('div');
                        durationBadge.className = 'todo-card-badge duration';
                        durationBadge.textContent = '‚è±Ô∏è ' + task.duration + ' min';
                        meta.appendChild(durationBadge);
                    }

                    // Due date badge
                    if (task.dueDate) {
                        const dueBadge = document.createElement('div');
                        dueBadge.className = 'todo-card-badge';
                        
                        const now = new Date();
                        now.setHours(0, 0, 0, 0);
                        const due = new Date(task.dueDate);
                        due.setHours(0, 0, 0, 0);
                        const daysUntil = Math.floor((due - now) / (1000 * 60 * 60 * 24));
                        
                        if (daysUntil < 0) {
                            dueBadge.textContent = '‚ö†Ô∏è Overdue';
                            dueBadge.style.background = '#FFCDD2';
                            dueBadge.style.color = '#C62828';
                        } else if (daysUntil === 0) {
                            dueBadge.textContent = 'üìÖ Today';
                            dueBadge.style.background = '#FFF9C4';
                            dueBadge.style.color = '#F57F17';
                        } else if (daysUntil === 1) {
                            dueBadge.textContent = 'üìÖ Tomorrow';
                            dueBadge.style.background = '#E8F5E9';
                            dueBadge.style.color = '#2E7D32';
                        } else {
                            dueBadge.textContent = 'üìÖ ' + task.dueDate;
                        }
                        meta.appendChild(dueBadge);
                    }
                    
                    // Financial value badge
                    if (task.financialValue && task.financialValue !== 0) {
                        const financialBadge = document.createElement('div');
                        financialBadge.className = 'financial-badge' + (task.financialValue < 0 ? ' negative' : '');
                        const sign = task.financialValue > 0 ? '+' : '';
                        financialBadge.textContent = 'üí∞ ' + sign + '$' + Math.abs(task.financialValue).toFixed(2);
                        meta.appendChild(financialBadge);
                    }

                    content.appendChild(meta);
                    header.appendChild(content);

                    // Priority score
                    const priorityDiv = document.createElement('div');
                    priorityDiv.className = 'todo-card-priority';
                    const priorityValue = Math.round(priority);
                    priorityDiv.textContent = priorityValue.toString();
                    priorityDiv.title = `Priority Score: ${priorityValue}`;
                    
                    if (priorityValue >= 60) {
                        priorityDiv.style.background = '#FFCDD2';
                        priorityDiv.style.color = '#C62828';
                    } else if (priorityValue >= 40) {
                        priorityDiv.style.background = '#FFF9C4';
                        priorityDiv.style.color = '#F57F17';
                    } else {
                        priorityDiv.style.background = '#E8F5E9';
                        priorityDiv.style.color = '#2E7D32';
                    }
                    
                    header.appendChild(priorityDiv);
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'todo-card-delete';
                    deleteBtn.innerHTML = '√ó';
                    deleteBtn.title = 'Delete task';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Delete "${task.title}"?`)) {
                            this.deleteTask(task.id);
                        }
                    };
                    header.appendChild(deleteBtn);
                    
                    card.appendChild(header);

                    // Note section (if exists)
                    if (task.note) {
                        const note = document.createElement('div');
                        note.className = 'todo-card-note';
                        note.textContent = task.note;
                        card.appendChild(note);
                    }

                    container.appendChild(card);
                });

                if (filtered.length === 0) {
                    if (incompleteTasks.length === 0) {
                        container.innerHTML = '<p style="padding: 40px; text-align: center; color: #666; grid-column: 1 / -1;">No tasks! Add subtasks under your life areas. üìù</p>';
                    } else {
                        container.innerHTML = '<p style="padding: 40px; text-align: center; color: #666; grid-column: 1 / -1;">No tasks match filters. Try "All places". üéâ</p>';
                    }
                }
            },

            updateTodoList() {
                const container = document.getElementById('todo-cards-grid');
                container.style.opacity = '0.5';
                
                setTimeout(() => {
                    this.renderTodoList();
                    container.style.opacity = '1';
                    
                    const timestamp = document.getElementById('last-update');
                    if (timestamp) {
                        const now = new Date();
                        timestamp.textContent = `Updated: ${now.toLocaleTimeString()}`;
                    }
                }, 100);
            },

            // ============================================================================
            // TIMER FUNCTIONS
            // ============================================================================

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                if (hours > 0) {
                    return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
                return `${minutes}:${String(seconds).padStart(2, '0')}`;
            },

            // Pomodoro Timer Functions (30-minute units)
            startPomodoroTimer(taskId) {
                // Ensure taskTimers exists
                if (!this.data.taskTimers) {
                    this.data.taskTimers = {};
                }
                
                if (!this.data.taskTimers[taskId]) {
                    this.data.taskTimers[taskId] = { elapsed: 0, running: false };
                }
                
                this.data.taskTimers[taskId].startTime = Date.now();
                this.data.taskTimers[taskId].running = true;
                
                this.saveData();
                this.updatePomodoroTimers();
            },

            pausePomodoroTimer(taskId) {
                if (!this.data.taskTimers) {
                    this.data.taskTimers = {};
                }
                
                const timer = this.data.taskTimers[taskId];
                if (timer && timer.running) {
                    const now = Date.now();
                    timer.elapsed += (now - timer.startTime);
                    timer.running = false;
                    timer.startTime = null;
                    
                    this.saveData();
                    this.renderTodoList();
                }
            },

            resetPomodoroTimer(taskId) {
                if (!this.data.taskTimers) {
                    this.data.taskTimers = {};
                }
                
                if (this.data.taskTimers[taskId]) {
                    const POMODORO_DURATION = 30 * 60 * 1000;
                    const currentElapsed = this.data.taskTimers[taskId].elapsed;
                    
                    // Reset to the start of the current unit
                    const completedUnits = Math.floor(currentElapsed / POMODORO_DURATION);
                    this.data.taskTimers[taskId].elapsed = completedUnits * POMODORO_DURATION;
                    this.data.taskTimers[taskId].running = false;
                    this.data.taskTimers[taskId].startTime = null;
                    
                    this.saveData();
                    this.renderTodoList();
                }
            },

            updatePomodoroTimers() {
                // Ensure taskTimers exists
                if (!this.data.taskTimers) {
                    this.data.taskTimers = {};
                    return;
                }
                
                const POMODORO_DURATION = 30 * 60 * 1000; // 30 minutes
                
                // Update all running timers
                let hasRunningTimers = false;
                
                for (const taskId in this.data.taskTimers) {
                    const timer = this.data.taskTimers[taskId];
                    if (timer.running) {
                        hasRunningTimers = true;
                        const now = Date.now();
                        const currentElapsed = timer.elapsed + (now - timer.startTime);
                        
                        // Check if a unit was completed
                        const completedUnits = Math.floor(currentElapsed / POMODORO_DURATION);
                        const previousCompletedUnits = Math.floor(timer.elapsed / POMODORO_DURATION);
                        
                        if (completedUnits > previousCompletedUnits) {
                            // A new unit was completed!
                            const task = this.findTask(taskId);
                            if (task) {
                                task.pomodoroUnits = (task.pomodoroUnits || 0) + 1;
                                this.saveData();
                                
                                // Play a sound or show notification
                                this.notifyPomodoroComplete(task);
                                
                                // Auto-pause the timer after unit completion
                                timer.elapsed = currentElapsed;
                                timer.running = false;
                                timer.startTime = null;
                                this.saveData();
                                this.renderTodoList();
                                continue;
                            }
                        }
                        
                        // Calculate remaining time in current unit (countdown)
                        const remainingInUnit = POMODORO_DURATION - (currentElapsed % POMODORO_DURATION);
                        const progressPercent = ((currentElapsed % POMODORO_DURATION) / POMODORO_DURATION) * 100;
                        
                        // Update countdown display
                        const displayEl = document.getElementById(`timer-display-${taskId}`);
                        if (displayEl) {
                            displayEl.textContent = this.formatTime(remainingInUnit);
                        }
                        
                        // Update progress bar with dynamic color
                        const progressEl = document.getElementById(`pomodoro-progress-${taskId}`);
                        if (progressEl) {
                            progressEl.style.width = progressPercent + '%';
                            
                            // Dynamic color based on progress
                            let barColor;
                            if (progressPercent < 33) {
                                barColor = '#4CAF50';
                            } else if (progressPercent < 66) {
                                barColor = '#FFC107';
                            } else if (progressPercent < 90) {
                                barColor = '#FF9800';
                            } else {
                                barColor = '#F44336';
                            }
                            progressEl.style.background = barColor;
                        }
                    }
                }
                
                // Continue updating if there are running timers
                if (hasRunningTimers && this.data.settings.currentView === 'todo') {
                    setTimeout(() => this.updatePomodoroTimers(), 100); // Update more frequently for smooth countdown
                }
            },
            
            notifyPomodoroComplete(task) {
                // Visual and audio feedback when a 30-minute unit is completed
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('Pomodoro Unit Complete! üéâ', {
                        body: `You completed 1 unit (30 min) on: ${task.title}`,
                        icon: 'icon.png'
                    });
                }
                
                // Play a completion sound (browser beep)
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio notification not available');
                }
            },

            startTimer(taskId) {
                // Legacy timer function - redirects to Pomodoro timer
                this.startPomodoroTimer(taskId);
            },

            pauseTimer(taskId) {
                // Legacy timer function - redirects to Pomodoro timer
                this.pausePomodoroTimer(taskId);
            },

            resetTimer(taskId) {
                // Legacy timer function - redirects to Pomodoro timer
                this.resetPomodoroTimer(taskId);
            },

            updateTimers() {
                // Legacy timer update - redirects to Pomodoro timer
                this.updatePomodoroTimers();
            },

            renderPlaces() {
                const listContainer = document.getElementById('places-list');
                listContainer.innerHTML = '';
                
                const now = new Date();

                this.data.places.forEach(place => {
                    const div = document.createElement('div');
                    div.className = 'place-item' + 
                        (this.data.settings.selectedPlaceId === place.id ? ' selected' : '');
                    
                    const isOpen = place.isAvailableAt(now);
                    const statusIcon = isOpen ? 'üü¢' : 'üî¥';
                    
                    div.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${place.name}</span>
                            <span style="font-size: 9px;">${statusIcon}</span>
                        </div>
                    `;
                    
                    div.onclick = () => this.selectPlace(place.id);
                    listContainer.appendChild(div);
                });

                const addBtn = document.createElement('button');
                addBtn.className = 'btn';
                addBtn.textContent = '+ New Place';
                addBtn.style.marginTop = '8px';
                addBtn.onclick = () => this.addPlace();
                listContainer.appendChild(addBtn);

                if (this.data.settings.selectedPlaceId) {
                    this.renderPlaceDetail();
                }
            },

            renderPlaceDetail() {
                const place = this.data.places.find(p => p.id === this.data.settings.selectedPlaceId);
                if (!place) return;

                // Render controls in left pane
                const controlsContainer = document.getElementById('place-controls');
                controlsContainer.innerHTML = `
                    <h3>${place.name}</h3>
                    <div class="button-group" style="display: flex; flex-direction: column; gap: 8px; border: none; padding: 0; margin-top: 12px;">
                        <button class="btn" onclick="app.setPlaceAlwaysOpen()">Always Open</button>
                        <button class="btn" onclick="app.setPlaceAlwaysClosed()">Always Closed</button>
                        <button class="btn" onclick="app.setPlaceWeekdayHours()">Weekday 9-5</button>
                    </div>
                `;

                // Render heatmap in right pane
                const heatmapPane = document.getElementById('places-heatmap-pane');
                heatmapPane.innerHTML = `
                    <div class="heat-map">
                        <h3 style="margin-bottom: 16px;">${place.name} - Weekly Schedule</h3>
                        <div class="heat-map-grid" id="heat-map-grid"></div>
                    </div>
                `;

                const grid = document.getElementById('heat-map-grid');
                const days = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                const hours = ['12am', '3am', '6am', '9am', '12pm', '3pm', '6pm', '9pm'];
                const dayKeys = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];

                days.forEach(day => {
                    const cell = document.createElement('div');
                    cell.className = 'heat-map-cell header';
                    cell.textContent = day;
                    grid.appendChild(cell);
                });

                for (let h = 0; h < 24; h += 3) {
                    const hourCell = document.createElement('div');
                    hourCell.className = 'heat-map-cell hour';
                    hourCell.textContent = hours[h / 3];
                    grid.appendChild(hourCell);

                    dayKeys.forEach(dayKey => {
                        const cell = document.createElement('div');
                        cell.className = 'heat-map-cell time ' + 
                            (place.schedule[dayKey][h] ? 'open' : 'closed');
                        cell.onclick = () => this.togglePlaceHour(place.id, dayKey, h);
                        grid.appendChild(cell);
                    });
                }
            },

            togglePlaceHour(placeId, day, hour) {
                const place = this.data.places.find(p => p.id === placeId);
                if (!place) return;

                for (let h = hour; h < hour + 3 && h < 24; h++) {
                    place.schedule[day][h] = !place.schedule[day][h];
                }

                this.saveData();
                this.renderPlaceDetail();
            },

            setPlaceAlwaysOpen() {
                const place = this.data.places.find(p => p.id === this.data.settings.selectedPlaceId);
                if (place) {
                    place.setAlwaysOpen();
                    this.saveData();
                    this.renderPlaceDetail();
                }
            },

            setPlaceAlwaysClosed() {
                const place = this.data.places.find(p => p.id === this.data.settings.selectedPlaceId);
                if (place) {
                    const days = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
                    days.forEach(day => {
                        place.schedule[day] = new Array(24).fill(false);
                    });
                    this.saveData();
                    this.renderPlaceDetail();
                }
            },

            setPlaceWeekdayHours() {
                const place = this.data.places.find(p => p.id === this.data.settings.selectedPlaceId);
                if (place) {
                    place.setWeekdayHours(9, 17);
                    this.saveData();
                    this.renderPlaceDetail();
                }
            },

            selectPlace(placeId) {
                this.data.settings.selectedPlaceId = placeId;
                this.saveData();
                this.renderPlaces();
            },

            addPlace() {
                const name = prompt('Enter place name:');
                if (name) {
                    const place = new Place(name);
                    this.data.places.push(place);
                    this.saveData();
                    this.renderPlaces();
                    this.updatePlaceFilters();
                }
            },

            renderBalance() {
                console.log('renderBalance called');
                const { desired, actual, topLevelTasks } = this.calculateBalance();
                
                console.log('Top level tasks:', topLevelTasks.map(t => t.title + ': ' + (t.desiredPercentage || 0) + '%').join(', '));

                const legend = document.getElementById('balance-legend');
                if (!legend) {
                    console.error('Legend element not found!');
                    return;
                }
                
                // Check if there are any top-level tasks
                if (topLevelTasks.length === 0) {
                    // Clear the charts
                    const desiredCanvas = document.getElementById('desired-chart');
                    const actualCanvas = document.getElementById('actual-chart');
                    if (desiredCanvas) {
                        const ctx = desiredCanvas.getContext('2d');
                        ctx.clearRect(0, 0, desiredCanvas.width, desiredCanvas.height);
                    }
                    if (actualCanvas) {
                        const ctx = actualCanvas.getContext('2d');
                        ctx.clearRect(0, 0, actualCanvas.width, actualCanvas.height);
                    }
                    
                    // Show helpful message
                    legend.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: var(--lb-text-muted);">
                            <h4 style="margin-bottom: 12px;">No Life Areas Yet</h4>
                            <p style="margin-bottom: 8px;">Create top-level tasks in the Outline view to define your life areas (Work, Family, Health, etc.)</p>
                            <p style="font-size: 12px; margin-bottom: 8px;">Then set a Weight (%) for each area in the task details panel.</p>
                            <p style="font-size: 11px; font-style: italic;">Tip: Top-level tasks are never purged - they're permanent placeholders for your life balance.</p>
                        </div>
                    `;
                    console.log('No top-level tasks with weights found');
                    return;
                }

                this.renderPieChart('desired-chart', desired, topLevelTasks);
                this.renderPieChart('actual-chart', actual, topLevelTasks);
                
                legend.innerHTML = '<h4>Life Areas</h4>';
                
                topLevelTasks.forEach(task => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color color-${task.color}"></div>
                        <span><strong>${task.title}</strong>: Desired ${desired[task.id]}%, Actual ${actual[task.id]}%</span>
                    `;
                    legend.appendChild(item);
                });
                
                console.log('renderBalance complete');
            },

            renderPieChart(canvasId, percentages, tasks) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 100;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Normalize percentages to ensure they total exactly 100%
                const total = tasks.reduce((sum, task) => sum + (percentages[task.id] || 0), 0);
                const normalizedPercentages = {};
                if (total > 0) {
                    tasks.forEach(task => {
                        normalizedPercentages[task.id] = (percentages[task.id] || 0) / total * 100;
                    });
                } else {
                    tasks.forEach(task => {
                        normalizedPercentages[task.id] = 0;
                    });
                }

                let currentAngle = -Math.PI / 2;

                tasks.forEach(task => {
                    const percent = normalizedPercentages[task.id] || 0;
                    const displayPercent = Math.round(percentages[task.id] || 0); // Use original for display
                    const sliceAngle = (percent / 100) * 2 * Math.PI;

                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                    ctx.closePath();

                    const colorMap = {
                        red: '#FFB3B3',
                        green: '#B3FFB3',
                        blue: '#B3D9FF',
                        yellow: '#FFFFB3',
                        purple: '#D9B3FF',
                        pink: '#FFCCFF',
                        orange: '#FFD9B3'
                    };
                    ctx.fillStyle = colorMap[task.color] || '#CCCCCC';
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    if (percent > 0) {
                        const labelAngle = currentAngle + sliceAngle / 2;
                        const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                        const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(displayPercent + '%', labelX, labelY);
                    }

                    // Draw drag handle on boundaries (only for desired chart)
                    if (canvasId === 'desired-chart' && percent > 0) {
                        const endAngle = currentAngle + sliceAngle;
                        const handleX = centerX + Math.cos(endAngle) * radius;
                        const handleY = centerY + Math.sin(endAngle) * radius;
                        
                        ctx.beginPath();
                        ctx.arc(handleX, handleY, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = '#2196F3';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    currentAngle += sliceAngle;
                });
            },

            initializeInteractivePieChart() {
                const canvas = document.getElementById('desired-chart');
                if (!canvas) {
                    console.error('Desired chart canvas not found!');
                    return;
                }

                console.log('Initializing interactive pie chart');
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                canvas.style.cursor = 'pointer';

                const updateFromClick = (clientX, clientY) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;

                    // Calculate angle from center
                    const dx = x - centerX;
                    const dy = y - centerY;
                    let angle = Math.atan2(dy, dx) + Math.PI / 2;
                    if (angle < 0) angle += 2 * Math.PI;
                    
                    // Convert to percentage
                    const clickPercentage = (angle / (2 * Math.PI)) * 100;

                    // Get top level tasks
                    const topLevelTasks = this.data.tasks.filter(t => !t.parentId);
                    if (topLevelTasks.length < 2) {
                        console.log('Not enough segments');
                        return;
                    }

                    // Find which boundary is closest to the click
                    let cumulativePercent = 0;
                    let closestBoundaryIndex = 0;
                    let closestDistance = Infinity;
                    
                    topLevelTasks.forEach((task, index) => {
                        cumulativePercent += task.weight || 0;
                        const distance = Math.min(
                            Math.abs(clickPercentage - cumulativePercent),
                            Math.abs(clickPercentage - (cumulativePercent - 100)),
                            Math.abs(clickPercentage - (cumulativePercent + 100))
                        );
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestBoundaryIndex = index;
                        }
                    });

                    console.log('Adjusting boundary after segment', closestBoundaryIndex);

                    // Calculate what the cumulative percentage should be at this boundary
                    let percentBefore = 0;
                    for (let i = 0; i < closestBoundaryIndex; i++) {
                        percentBefore += topLevelTasks[i].weight || 0;
                    }
                    
                    // The clicked segment should resize to match
                    const currentSegment = topLevelTasks[closestBoundaryIndex];
                    const nextSegment = topLevelTasks[(closestBoundaryIndex + 1) % topLevelTasks.length];
                    
                    const oldCurrent = currentSegment.weight || 20;
                    const oldNext = nextSegment.weight || 20;
                    
                    // New size for current segment based on click
                    let newCurrent = Math.max(5, Math.min(95, clickPercentage - percentBefore));
                    let newNext = oldCurrent + oldNext - newCurrent;
                    
                    // Ensure next segment doesn't go below 5%
                    if (newNext < 5) {
                        newNext = 5;
                        newCurrent = oldCurrent + oldNext - 5;
                    }
                    
                    currentSegment.weight = Math.round(newCurrent);
                    nextSegment.weight = Math.round(newNext);
                    
                    console.log('Updated:', currentSegment.title, '=', newCurrent, '%', nextSegment.title, '=', newNext, '%');
                    
                    // Normalize to 100%
                    const total = topLevelTasks.reduce((sum, t) => sum + (t.weight || 0), 0);
                    if (total !== 100) {
                        nextSegment.weight += (100 - total);
                    }
                    
                    this.saveData();
                    this.renderBalance();
                };

                canvas.addEventListener('click', (e) => {
                    console.log('Canvas clicked!');
                    updateFromClick(e.clientX, e.clientY);
                });

                canvas.addEventListener('touchend', (e) => {
                    if (e.changedTouches && e.changedTouches[0]) {
                        console.log('Canvas touched!');
                        updateFromClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                    }
                });
                
                console.log('Interactive pie chart initialized');
            },




            renderTaskDetail() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                
                if (!task) {
                    document.getElementById('task-title-input').value = '';
                    return;
                }

                document.getElementById('task-title-input').value = task.title;

                document.getElementById('importance-of').textContent = task.title;
                document.getElementById('importance-to').textContent = 
                    task.parentId ? this.findTask(task.parentId).title : 'Your life as a whole';
                document.getElementById('importance-slider').value = task.importance;
                this.updateImportanceLabel();

                document.getElementById('task-place').value = task.place;

                if (!task.parentId) {
                    document.getElementById('color-group').style.display = 'block';
                    document.getElementById('weight-group').style.display = 'block';
                    document.getElementById('task-color').value = task.color || 'blue';
                    document.getElementById('task-weight').value = task.weight || 0;
                } else {
                    document.getElementById('color-group').style.display = 'none';
                    document.getElementById('weight-group').style.display = 'none';
                }

                document.getElementById('task-due-date').value = task.dueDate || '';
                document.getElementById('task-due-time').value = task.dueTime || '';
                document.getElementById('task-duration').value = task.duration || '';
                document.getElementById('task-financial-value').value = task.financialValue || '';
                document.getElementById('task-start-date').value = task.startDate || '';
                document.getElementById('task-lead-time').value = task.leadTime || '';
                document.getElementById('task-recurrence').value = task.recurrencePattern || 'none';
                
                // Do NOT manipulate tabs here - tabs are managed by switchTab() only
                
                // Show/hide recurrence configuration panels
                const configContainer = document.getElementById('recurrence-config');
                const configs = {
                    'every-x-days': 'config-every-x-days',
                    'weekly': 'config-weekly',
                    'x-per-week': 'config-x-per-week',
                    'monthly-date': 'config-monthly-date',
                    'monthly-relative': 'config-monthly-relative'
                };
                
                // Hide all config panels first
                Object.values(configs).forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                });
                
                // Show and populate appropriate config panel
                const pattern = task.recurrencePattern;
                if (configs[pattern]) {
                    configContainer.style.display = 'block';
                    document.getElementById(configs[pattern]).style.display = 'block';
                    
                    // Populate fields based on pattern
                    switch (pattern) {
                        case 'every-x-days':
                            document.getElementById('recurrence-interval').value = task.recurrenceInterval || 1;
                            break;
                            
                        case 'weekly':
                            // Uncheck all first
                            document.querySelectorAll('.weekday-check').forEach(cb => cb.checked = false);
                            // Check selected days
                            if (task.recurrenceWeekdays && task.recurrenceWeekdays.length > 0) {
                                task.recurrenceWeekdays.forEach(day => {
                                    const cb = document.querySelector(`.weekday-check[value="${day}"]`);
                                    if (cb) cb.checked = true;
                                });
                            }
                            break;
                            
                        case 'x-per-week':
                            document.getElementById('recurrence-count').value = task.recurrenceCount || 3;
                            break;
                            
                        case 'monthly-date':
                            document.getElementById('recurrence-month-date').value = task.recurrenceMonthDate || 1;
                            break;
                            
                        case 'monthly-relative':
                            document.getElementById('recurrence-month-week').value = task.recurrenceMonthWeek || 'first';
                            document.getElementById('recurrence-month-day').value = task.recurrenceMonthDay || 'monday';
                            break;
                    }
                } else {
                    configContainer.style.display = 'none';
                }

                document.getElementById('task-estimated-effort').value = task.estimatedEffort || 25;
                document.getElementById('task-actual-effort').value = task.actualEffort || '';

                document.getElementById('task-note').value = task.note || '';
                
                // Restore current tab state - this must be at the END after all fields are populated
                const currentTab = this.data.settings.currentTab || 'general';
                
                // Update tab buttons
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.remove('active');
                });
                const activeTabButton = document.querySelector(`[data-tab="${currentTab}"]`);
                if (activeTabButton) {
                    activeTabButton.classList.add('active');
                }
                
                // Update tab panels
                document.querySelectorAll('.tab-panel').forEach(p => {
                    p.style.display = 'none';
                });
                const activePanel = document.getElementById(`tab-${currentTab}`);
                if (activePanel) {
                    activePanel.style.display = 'block';
                }
                
                // Update progress bar
                this.updateTaskProgress();
            },
            
            // Update live progress bar for current task
            updateTaskProgress() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                const container = document.getElementById('task-progress-container');
                
                if (!container) return;
                
                // Only show if task has both time and duration
                if (!task || !task.dueDate || !task.dueTime || !task.duration) {
                    container.style.display = 'none';
                    return;
                }
                
                const now = new Date();
                const taskDate = new Date(task.dueDate + 'T' + task.dueTime);
                const taskEnd = new Date(taskDate.getTime() + task.duration * 60000);
                
                // Only show if task is happening now
                if (now < taskDate || now > taskEnd) {
                    container.style.display = 'none';
                    return;
                }
                
                // Calculate progress
                const totalMs = taskEnd - taskDate;
                const elapsedMs = now - taskDate;
                const remainingMs = taskEnd - now;
                
                const percentage = Math.min(100, Math.max(0, (elapsedMs / totalMs) * 100));
                const elapsedMin = Math.floor(elapsedMs / 60000);
                const remainingMin = Math.ceil(remainingMs / 60000);
                
                // Update UI
                container.style.display = 'block';
                document.getElementById('progress-title').textContent = `‚è±Ô∏è ${task.title}`;
                document.getElementById('progress-time').textContent = `${task.dueTime} - ${taskEnd.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'})}`;
                document.getElementById('progress-bar').style.width = percentage + '%';
                document.getElementById('progress-percentage').textContent = Math.round(percentage) + '%';
                document.getElementById('progress-elapsed').textContent = `Elapsed: ${elapsedMin}m`;
                document.getElementById('progress-remaining').textContent = `Remaining: ${remainingMin}m`;
                
                // Auto-update every second
                clearTimeout(this.progressTimer);
                this.progressTimer = setTimeout(() => this.updateTaskProgress(), 1000);
            },

            selectTask(taskId) {
                this.data.settings.selectedTaskId = taskId;
                this.saveData();
                this.render();
            },

            // ============================================================================
            // DRAG AND DROP
            // ============================================================================

            handleDragStart(e, task) {
                e.stopPropagation();
                this.draggedTask = task;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'copyMove'; // Allow both copy and move
                e.dataTransfer.setData('text/html', e.target.innerHTML);
            },

            handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault();
                }
                e.dataTransfer.dropEffect = 'move';
                return false;
            },

            handleDragEnter(e) {
                e.preventDefault();
                const target = e.currentTarget;
                if (target.dataset.taskId) {
                    const rect = target.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    if (e.clientY < midpoint) {
                        target.classList.add('drag-over');
                    } else {
                        target.classList.add('drag-over-child');
                    }
                }
            },

            handleDragLeave(e) {
                const target = e.currentTarget;
                target.classList.remove('drag-over');
                target.classList.remove('drag-over-child');
            },

            handleDrop(e, targetTask) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                e.preventDefault();

                const target = e.currentTarget;
                target.classList.remove('drag-over');
                target.classList.remove('drag-over-child');

                if (!this.draggedTask || this.draggedTask.id === targetTask.id) {
                    return false;
                }

                if (this.isDescendant(targetTask, this.draggedTask)) {
                    alert('Cannot move a task into its own subtask!');
                    return false;
                }

                const rect = target.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                
                if (e.clientY < midpoint) {
                    this.draggedTask.parentId = targetTask.parentId;
                } else {
                    this.draggedTask.parentId = targetTask.id;
                    targetTask.expanded = true;
                }

                this.saveData();
                this.render();
                return false;
            },

            handleDragEnd(e) {
                // Remove dragging class from target (drag handle) and all task items
                if (e.target) {
                    e.target.classList.remove('dragging');
                }
                document.querySelectorAll('.task-item').forEach(item => {
                    item.classList.remove('drag-over');
                    item.classList.remove('drag-over-child');
                    item.classList.remove('dragging');
                });
                this.draggedTask = null;
            },

            isDescendant(potentialChild, potentialParent) {
                if (!potentialChild.parentId) return false;
                if (potentialChild.parentId === potentialParent.id) return true;
                
                const parent = this.findTask(potentialChild.parentId);
                if (!parent) return false;
                
                return this.isDescendant(parent, potentialParent);
            },

            // ============================================================================
            // CALENDAR DRAG AND DROP
            // ============================================================================

            handleCalendarDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault();
                }
                e.dataTransfer.dropEffect = 'copy';
                return false;
            },

            handleCalendarDragEnter(e) {
                e.preventDefault();
                const target = e.currentTarget;
                if (target.dataset.date && this.draggedTask) {
                    target.classList.add('calendar-drag-over');
                }
            },

            handleCalendarDragLeave(e) {
                const target = e.currentTarget;
                target.classList.remove('calendar-drag-over');
            },

            handleCalendarDrop(e, dateStr) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                e.preventDefault();

                const target = e.currentTarget;
                target.classList.remove('calendar-drag-over');

                if (!this.draggedTask) {
                    return false;
                }

                // Ask if user wants to set a specific time (make it an event)
                const setTime = confirm(`Schedule "${this.draggedTask.title}" for ${dateStr}?\n\nClick OK to set a specific time (creates calendar event)\nClick Cancel to set as due date only (remains a task)`);
                
                if (setTime) {
                    const timeStr = prompt('Enter time (HH:MM format, e.g., 14:30 for 2:30 PM):', '09:00');
                    if (timeStr) {
                        // Validate time format
                        const timeMatch = timeStr.match(/^(\d{1,2}):(\d{2})$/);
                        if (timeMatch) {
                            const hours = parseInt(timeMatch[1]);
                            const minutes = parseInt(timeMatch[2]);
                            if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
                                this.draggedTask.dueDate = dateStr;
                                this.draggedTask.dueTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                                
                                // Set default duration if not set
                                if (!this.draggedTask.duration) {
                                    this.draggedTask.duration = 60; // 1 hour default
                                }
                                
                                this.showToast(`üìÖ "${this.draggedTask.title}" scheduled for ${dateStr} at ${this.draggedTask.dueTime}`);
                            } else {
                                alert('Invalid time. Hours must be 0-23, minutes 0-59.');
                                return false;
                            }
                        } else {
                            alert('Invalid time format. Please use HH:MM format (e.g., 14:30)');
                            return false;
                        }
                    } else {
                        return false; // User cancelled
                    }
                } else {
                    // Just set due date, no time
                    this.draggedTask.dueDate = dateStr;
                    this.draggedTask.dueTime = null;
                    this.showToast(`üìÖ "${this.draggedTask.title}" due date set to ${dateStr}`);
                }

                this.saveData();
                this.render();
                return false;
            },

            // ============================================================================
            // TEXT DROP ZONE
            // ============================================================================

            initTextDropZone() {
                const container = document.getElementById('outline-container');
                
                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
                
                container.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    if (e.dataTransfer.types.includes('text/plain')) {
                        container.classList.add('drop-active');
                    }
                });
                
                container.addEventListener('dragleave', (e) => {
                    // Only remove if we're leaving the container itself, not a child
                    if (e.target === container) {
                        container.classList.remove('drop-active');
                    }
                });
                
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    container.classList.remove('drop-active');
                    
                    const text = e.dataTransfer.getData('text/plain');
                    if (text) {
                        this.handleTextDrop(text);
                    }
                });
            },

            handleTextDrop(text) {
                const parsedTasks = this.parseIndentedText(text);
                
                if (parsedTasks.length === 0) {
                    this.showToast('‚ö†Ô∏è No valid tasks found in dropped text');
                    return;
                }
                
                const parentId = this.data.settings.selectedTaskId || null;
                const createdTasks = this.createTasksFromParsed(parsedTasks, parentId);
                
                // Select the first created task
                if (createdTasks.length > 0) {
                    this.selectTask(createdTasks[0].id);
                }
                
                this.saveData();
                this.render();
                this.showToast(`‚úÖ Created ${createdTasks.length} task${createdTasks.length !== 1 ? 's' : ''}`);
            },

            parseIndentedText(text) {
                const lines = text.split('\n').filter(line => line.trim().length > 0);
                const tasks = [];
                const stack = []; // Stack to track parent tasks at each level
                
                for (const line of lines) {
                    // Detect indentation level
                    const match = line.match(/^(\s*)/);
                    const indentStr = match[1];
                    
                    // Count spaces and tabs (tab = 4 spaces)
                    const spaceCount = indentStr.replace(/\t/g, '    ').length;
                    const level = Math.floor(spaceCount / 2); // 2 spaces = 1 level
                    
                    const title = line.trim();
                    
                    // Skip empty lines or lines that are just bullet points
                    if (!title || title === '-' || title === '*') {
                        continue;
                    }
                    
                    // Remove common bullet point prefixes
                    const cleanTitle = title.replace(/^[-*‚Ä¢]\s*/, '').trim();
                    
                    if (!cleanTitle) {
                        continue;
                    }
                    
                    // Determine parent based on level
                    let parentTask = null;
                    if (level > 0 && stack.length >= level) {
                        parentTask = stack[level - 1];
                    }
                    
                    const taskData = {
                        title: cleanTitle,
                        level: level,
                        parent: parentTask
                    };
                    
                    tasks.push(taskData);
                    
                    // Update stack for this level
                    stack[level] = taskData;
                    // Clear deeper levels
                    stack.length = level + 1;
                }
                
                return tasks;
            },

            createTasksFromParsed(parsedTasks, parentId) {
                const createdTasks = [];
                const taskMap = new Map(); // Maps parsed task data to created Task objects
                
                for (const parsed of parsedTasks) {
                    // Determine the actual parent ID
                    let actualParentId = null;
                    
                    if (parsed.parent) {
                        // This task has a parent in the parsed structure
                        const parentTask = taskMap.get(parsed.parent);
                        if (parentTask) {
                            actualParentId = parentTask.id;
                        }
                    } else if (parsed.level === 0 && parentId) {
                        // Top-level task and we have a selected parent
                        actualParentId = parentId;
                    }
                    
                    const task = new Task(parsed.title, actualParentId);
                    this.data.tasks.push(task);
                    createdTasks.push(task);
                    taskMap.set(parsed, task);
                }
                
                return createdTasks;
            },


            // ============================================================================
            // TASK OPERATIONS
            // ============================================================================

            addTask() {
                const title = prompt('Enter task title:');
                if (title) {
                    const task = new Task(title);
                    this.data.tasks.push(task);
                    this.saveData();
                    this.selectTask(task.id);
                    this.render();
                }
            },

            addSubtask() {
                if (!this.data.settings.selectedTaskId) {
                    alert('Please select a parent task first');
                    return;
                }

                const title = prompt('Enter subtask title:');
                if (title) {
                    const task = new Task(title, this.data.settings.selectedTaskId);
                    this.data.tasks.push(task);
                    this.saveData();
                    this.selectTask(task.id);
                    this.render();
                }
            },

            deleteTask(taskId) {
                if (confirm('Delete this task and all its subtasks?')) {
                    const task = this.findTask(taskId);
                    const toDelete = [taskId, ...task.getAllDescendants().map(t => t.id)];
                    
                    this.data.tasks = this.data.tasks.filter(t => !toDelete.includes(t.id));
                    
                    if (this.data.settings.selectedTaskId === taskId) {
                        this.data.settings.selectedTaskId = null;
                    }
                    
                    this.saveData();
                    this.render();
                }
            },

            purgeCompletedTasks() {
                // Count completed tasks (excluding top-level tasks which define life areas)
                const completedTasks = this.data.tasks.filter(t => t.completed && t.parentId);
                const count = completedTasks.length;
                
                if (count === 0) {
                    alert('No completed tasks to purge! ‚ú®\n\n(Top-level life area tasks are never purged to preserve your balance settings)');
                    return;
                }
                
                // Confirm with count
                const message = `This will permanently delete ${count} completed task${count !== 1 ? 's' : ''} from your database.\n\n` +
                               `Top-level life area tasks will be preserved to maintain your balance settings.\n\n` +
                               `Are you sure you want to continue?`;
                
                if (confirm(message)) {
                    // Remove completed tasks, but KEEP top-level tasks (they define life areas & balance)
                    this.data.tasks = this.data.tasks.filter(t => !t.completed || !t.parentId);
                    
                    // Clear selected task if it was completed and not top-level
                    if (this.data.settings.selectedTaskId) {
                        const selectedTask = this.findTask(this.data.settings.selectedTaskId);
                        if (!selectedTask) {
                            this.data.settings.selectedTaskId = null;
                        }
                    }
                    
                    this.saveData();
                    this.render();
                    
                    this.showToast(`üóëÔ∏è Purged ${count} completed task${count !== 1 ? 's' : ''}! (Life areas preserved)`);
                }
            },

            toggleTaskCompletion(taskId) {
                const task = this.findTask(taskId);
                if (!task) return;
                
                // Toggle completion status
                task.completed = !task.completed;
                task.completedAt = task.completed ? new Date().toISOString() : null;
                    
                    if (task.completed) {
                        const effort = prompt('How long did this take? (minutes)', task.estimatedEffort || 25);
                        if (effort) {
                            task.actualEffort = parseInt(effort);
                        }
                        
                        // Add financial value to income envelope if task has financial value
                        if (task.financialValue && task.financialValue !== 0) {
                            console.log('Task financial value:', task.financialValue);
                            console.log('Income envelope before:', this.data.incomeEnvelope.balance);
                            this.data.incomeEnvelope.balance += parseFloat(task.financialValue);
                            console.log('Income envelope after:', this.data.incomeEnvelope.balance);
                            const sign = task.financialValue > 0 ? '+' : '';
                            this.showToast(`üí∞ ${sign}$${task.financialValue.toFixed(2)} added to Income envelope`);
                            
                            // Update envelope view if it's currently visible
                            if (this.data.settings.currentView === 'envelopes') {
                                this.renderEnvelopesView();
                            }
                        }
                        
                        if (task.recurrencePattern !== 'none') {
                            // Clear the due date from completed recurring task so it doesn't show on calendar
                            const oldDueDate = task.dueDate;
                            const oldDueTime = task.dueTime;
                            task.dueDate = null;
                            task.dueTime = null;
                            
                            const nextTask = new Task(task.title, task.parentId);
                            nextTask.importance = task.importance;
                            nextTask.place = task.place;
                            nextTask.estimatedEffort = task.estimatedEffort;
                            nextTask.duration = task.duration;
                            nextTask.financialValue = task.financialValue; // Copy financial value to next recurrence
                            nextTask.recurrencePattern = task.recurrencePattern;
                            nextTask.recurrenceWeekdays = task.recurrenceWeekdays;
                            nextTask.recurrenceInterval = task.recurrenceInterval;
                            nextTask.recurrenceCount = task.recurrenceCount;
                            nextTask.recurrenceMonthDate = task.recurrenceMonthDate;
                            nextTask.recurrenceMonthWeek = task.recurrenceMonthWeek;
                            nextTask.recurrenceMonthDay = task.recurrenceMonthDay;
                            nextTask.leadTime = task.leadTime;
                            nextTask.note = task.note;
                            nextTask.dueTime = oldDueTime; // Preserve time for recurring events
                            nextTask.color = task.color;
                            
                            const nextDate = this.calculateNextRecurrence(task);
                            if (nextDate) {
                                const year = nextDate.getFullYear();
                                const month = String(nextDate.getMonth() + 1).padStart(2, '0');
                                const day = String(nextDate.getDate()).padStart(2, '0');
                                nextTask.dueDate = `${year}-${month}-${day}`;
                                
                                const duplicateExists = this.data.tasks.some(t => 
                                    t.title === nextTask.title && 
                                    t.dueDate === nextTask.dueDate && 
                                    t.parentId === nextTask.parentId &&
                                    t.id !== task.id
                                );
                                
                                if (!duplicateExists) {
                                    this.data.tasks.push(nextTask);
                                    
                                    const dateStr = nextDate.toLocaleDateString('en-US', { 
                                        weekday: 'short', 
                                        month: 'short', 
                                        day: 'numeric' 
                                    });
                                    this.showToast(`‚úì "${task.title}" completed!\nüîÑ Next: ${dateStr}`);
                                } else {
                                    this.showToast(`‚úì "${task.title}" completed!`);
                                }
                            } else {
                                this.showToast(`‚úì "${task.title}" completed!`);
                            }
                        } else {
                            this.showToast(`‚úì "${task.title}" completed!`);
                        }
                    } else {
                        // Unchecking - clear actual effort and reverse financial transaction
                        task.actualEffort = null;
                        if (task.financialValue && task.financialValue !== 0) {
                            this.data.incomeEnvelope.balance -= parseFloat(task.financialValue);
                        }
                        this.showToast(`‚Ü∂ "${task.title}" marked incomplete`);
                    }
                    
                    this.saveData();
                    
                    // Always do a full render to ensure calendar updates properly
                    this.render();
            },

            calculateNextRecurrence(task) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                switch (task.recurrencePattern) {
                    case 'daily':
                        today.setDate(today.getDate() + 1);
                        return today;
                        
                    case 'every-x-days':
                        const interval = task.recurrenceInterval || 1;
                        today.setDate(today.getDate() + interval);
                        return today;
                        
                    case 'weekly':
                        // Find next occurrence on specified weekdays
                        if (!task.recurrenceWeekdays || task.recurrenceWeekdays.length === 0) {
                            // Default to next week if no days specified
                            today.setDate(today.getDate() + 7);
                            return today;
                        }
                        
                        const weekdayMap = { sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6 };
                        const targetDays = task.recurrenceWeekdays.map(d => weekdayMap[d]).sort((a, b) => a - b);
                        const currentDay = today.getDay();
                        
                        // Find next target day
                        let daysToAdd = null;
                        for (const targetDay of targetDays) {
                            if (targetDay > currentDay) {
                                daysToAdd = targetDay - currentDay;
                                break;
                            }
                        }
                        
                        // If no day found this week, go to first day next week
                        if (daysToAdd === null) {
                            daysToAdd = (7 - currentDay) + targetDays[0];
                        }
                        
                        today.setDate(today.getDate() + daysToAdd);
                        return today;
                        
                    case 'x-per-week':
                        // For flexible "X times per week", just schedule for tomorrow
                        // User can complete on any day they choose
                        today.setDate(today.getDate() + 1);
                        return today;
                        
                    case 'monthly-date':
                        // Repeat on specific date of month
                        const targetDate = task.recurrenceMonthDate || 1;
                        today.setMonth(today.getMonth() + 1);
                        today.setDate(Math.min(targetDate, this.getDaysInMonth(today)));
                        return today;
                        
                    case 'monthly-relative':
                        // Repeat on relative day (e.g., "First Monday", "Last Friday")
                        const week = task.recurrenceMonthWeek || 'first';
                        const dayName = task.recurrenceMonthDay || 'monday';
                        return this.calculateMonthlyRelative(today, week, dayName);
                        
                    default:
                        return null;
                }
            },

            getDaysInMonth(date) {
                return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            },

            calculateMonthlyRelative(fromDate, week, dayName) {
                // Map day names to numbers
                const dayMap = {
                    sunday: 0, monday: 1, tuesday: 2, wednesday: 3,
                    thursday: 4, friday: 5, saturday: 6
                };
                const targetDay = dayMap[dayName];
                
                // Move to next month
                const nextMonth = new Date(fromDate);
                nextMonth.setMonth(nextMonth.getMonth() + 1);
                nextMonth.setDate(1);
                
                if (week === 'last') {
                    // Find last occurrence of day in month
                    const daysInMonth = this.getDaysInMonth(nextMonth);
                    nextMonth.setDate(daysInMonth);
                    
                    // Walk backwards to find the target day
                    while (nextMonth.getDay() !== targetDay) {
                        nextMonth.setDate(nextMonth.getDate() - 1);
                    }
                } else {
                    // Find first, second, third, or fourth occurrence
                    const weekNum = { first: 1, second: 2, third: 3, fourth: 4 }[week];
                    
                    // Find first occurrence of target day
                    while (nextMonth.getDay() !== targetDay) {
                        nextMonth.setDate(nextMonth.getDate() + 1);
                    }
                    
                    // Add weeks to get to desired occurrence
                    nextMonth.setDate(nextMonth.getDate() + ((weekNum - 1) * 7));
                    
                    // Make sure we didn't go past end of month
                    const daysInMonth = this.getDaysInMonth(new Date(nextMonth.getFullYear(), nextMonth.getMonth(), 1));
                    if (nextMonth.getDate() > daysInMonth) {
                        // This occurrence doesn't exist this month, use last occurrence
                        nextMonth.setDate(nextMonth.getDate() - 7);
                    }
                }
                
                return nextMonth;
            },

            getRecurrenceDescription(task) {
                switch (task.recurrencePattern) {
                    case 'daily':
                        return 'Repeats daily';
                    case 'every-x-days':
                        const days = task.recurrenceInterval || 1;
                        return `Repeats every ${days} day${days > 1 ? 's' : ''}`;
                    case 'weekly':
                        if (task.recurrenceWeekdays && task.recurrenceWeekdays.length > 0) {
                            const dayNames = {
                                mon: 'Mon', tue: 'Tue', wed: 'Wed', thu: 'Thu',
                                fri: 'Fri', sat: 'Sat', sun: 'Sun'
                            };
                            const days = task.recurrenceWeekdays.map(d => dayNames[d]).join(', ');
                            return `Repeats weekly: ${days}`;
                        }
                        return 'Repeats weekly';
                    case 'x-per-week':
                        const count = task.recurrenceCount || 3;
                        return `Repeats ${count}x per week`;
                    case 'monthly-date':
                        const date = task.recurrenceMonthDate || 1;
                        return `Repeats monthly on the ${this.getOrdinal(date)}`;
                    case 'monthly-relative':
                        const week = task.recurrenceMonthWeek || 'first';
                        const day = task.recurrenceMonthDay || 'monday';
                        return `Repeats ${week} ${day} of month`;
                    default:
                        return 'Repeats';
                }
            },

            getOrdinal(n) {
                const s = ['th', 'st', 'nd', 'rd'];
                const v = n % 100;
                return n + (s[(v - 20) % 10] || s[v] || s[0]);
            },

            showToast(message) {
                const existingToast = document.querySelector('.toast');
                if (existingToast) {
                    existingToast.remove();
                }

                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.style.whiteSpace = 'pre-line';
                toast.textContent = message;
                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.classList.add('hide');
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, 3000);
            },

            updateTaskTitle() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.title = document.getElementById('task-title-input').value;
                    this.saveData();
                    this.render();
                }
            },

            updateImportance() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.importance = parseInt(document.getElementById('importance-slider').value);
                    this.updateImportanceLabel();
                    this.saveData();
                    this.renderTodoList();
                }
            },

            updateImportanceLabel() {
                const value = parseInt(document.getElementById('importance-slider').value);
                const label = document.getElementById('importance-label');
                
                if (value <= 20) label.textContent = 'Trivial';
                else if (value <= 40) label.textContent = 'Minor';
                else if (value <= 60) label.textContent = 'Essential';
                else if (value <= 80) label.textContent = 'Important';
                else label.textContent = 'Critical';
            },

            updateTaskPlace() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.place = document.getElementById('task-place').value;
                    this.saveData();
                    this.renderTodoList();
                }
            },

            updateTaskColor() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.color = document.getElementById('task-color').value;
                    this.saveData();
                    this.render();
                }
            },

            updateTaskWeight() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.weight = parseInt(document.getElementById('task-weight').value);
                    this.saveData();
                    this.renderBalance();
                }
            },

            updateTaskDate() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.dueDate = document.getElementById('task-due-date').value;
                    this.saveData();
                    this.render();
                }
            },

            updateTaskTime() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.dueTime = document.getElementById('task-due-time').value;
                    this.saveData();
                }
            },

            updateTaskDuration() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.duration = parseInt(document.getElementById('task-duration').value) || null;
                    this.saveData();
                }
            },

            updateTaskStartDate() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.startDate = document.getElementById('task-start-date').value;
                    this.saveData();
                    this.renderTodoList();
                }
            },

            updateTaskLeadTime() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.leadTime = parseInt(document.getElementById('task-lead-time').value) || null;
                    this.saveData();
                    this.renderTodoList();
                }
            },

            updateTaskRecurrence() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    const pattern = document.getElementById('task-recurrence').value;
                    task.recurrencePattern = pattern;
                    
                    // Show/hide recurrence configuration based on pattern
                    const configContainer = document.getElementById('recurrence-config');
                    const configs = {
                        'every-x-days': 'config-every-x-days',
                        'weekly': 'config-weekly',
                        'x-per-week': 'config-x-per-week',
                        'monthly-date': 'config-monthly-date',
                        'monthly-relative': 'config-monthly-relative'
                    };
                    
                    // Hide all config panels
                    Object.values(configs).forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.style.display = 'none';
                    });
                    
                    // Show appropriate config panel
                    if (configs[pattern]) {
                        configContainer.style.display = 'block';
                        document.getElementById(configs[pattern]).style.display = 'block';
                    } else {
                        configContainer.style.display = 'none';
                    }
                    
                    this.saveData();
                    this.render();
                }
            },

            updateRecurrenceConfig() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (!task) return;
                
                const pattern = task.recurrencePattern;
                
                switch (pattern) {
                    case 'every-x-days':
                        task.recurrenceInterval = parseInt(document.getElementById('recurrence-interval').value) || 1;
                        break;
                        
                    case 'weekly':
                        // Get checked weekdays
                        const checkboxes = document.querySelectorAll('.weekday-check:checked');
                        task.recurrenceWeekdays = Array.from(checkboxes).map(cb => cb.value);
                        break;
                        
                    case 'x-per-week':
                        task.recurrenceCount = parseInt(document.getElementById('recurrence-count').value) || 1;
                        break;
                        
                    case 'monthly-date':
                        task.recurrenceMonthDate = parseInt(document.getElementById('recurrence-month-date').value) || 1;
                        break;
                        
                    case 'monthly-relative':
                        task.recurrenceMonthWeek = document.getElementById('recurrence-month-week').value;
                        task.recurrenceMonthDay = document.getElementById('recurrence-month-day').value;
                        break;
                }
                
                this.saveData();
            },

            updateTaskEstimatedEffort() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.estimatedEffort = parseInt(document.getElementById('task-estimated-effort').value) || 25;
                    this.saveData();
                }
            },

            updateTaskActualEffort() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.actualEffort = parseInt(document.getElementById('task-actual-effort').value) || null;
                    this.saveData();
                    this.renderBalance();
                }
            },

            updateTaskNote() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    task.note = document.getElementById('task-note').value;
                    this.saveData();
                }
            },

            // ============================================================================
            // CALENDAR
            // ============================================================================

            renderMiniCalendar() {
                const month = this.data.settings.calendarMonth;
                const year = month.getFullYear();
                const monthNum = month.getMonth();

                document.getElementById('calendar-month').textContent = 
                    month.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

                const grid = document.getElementById('mini-calendar');
                grid.innerHTML = '';

                ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach((day, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'calendar-day';
                    cell.style.fontWeight = 'bold';
                    cell.style.background = '#E0E0E0';
                    
                    // Lighter background for weekend headers (Sat = index 5, Sun = index 6)
                    if (index === 5 || index === 6) {
                        cell.style.background = '#d0d0d0';
                    }
                    
                    cell.textContent = day;
                    grid.appendChild(cell);
                });

                const firstDay = (new Date(year, monthNum, 1).getDay() + 6) % 7;
                const daysInMonth = new Date(year, monthNum + 1, 0).getDate();

                for (let i = 0; i < firstDay; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'calendar-day';
                    
                    // Add weekend styling to Saturday and Sunday columns
                    if (i === 5 || i === 6) {
                        cell.style.background = '#f0f0f0';
                    }
                    
                    grid.appendChild(cell);
                }

                const today = new Date();
                for (let day = 1; day <= daysInMonth; day++) {
                    const cell = document.createElement('div');
                    cell.className = 'calendar-day';
                    
                    const date = new Date(year, monthNum, day);
                    const dayOfWeek = date.getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday
                    const isToday = date.toDateString() === today.toDateString();
                    
                    if (isWeekend) {
                        cell.style.background = '#f0f0f0'; // Light grey for weekends
                    }
                    
                    if (isToday) {
                        cell.classList.add('today');
                    }

                    const dateYear = date.getFullYear();
                    const dateMonth = String(date.getMonth() + 1).padStart(2, '0');
                    const dateDay = String(date.getDate()).padStart(2, '0');
                    const dateStr = `${dateYear}-${dateMonth}-${dateDay}`;
                    
                    // Make calendar cells drop targets for tasks
                    cell.dataset.date = dateStr;
                    cell.ondragover = (e) => this.handleCalendarDragOver(e);
                    cell.ondragenter = (e) => this.handleCalendarDragEnter(e);
                    cell.ondragleave = (e) => this.handleCalendarDragLeave(e);
                    cell.ondrop = (e) => this.handleCalendarDrop(e, dateStr);
                    
                    const tasksOnDate = this.data.tasks.filter(t => t.dueDate === dateStr && !t.completed);
                    
                    const dayNumber = document.createElement('div');
                    dayNumber.style.fontWeight = 'bold';
                    dayNumber.style.marginBottom = '2px';
                    dayNumber.textContent = day;
                    cell.appendChild(dayNumber);
                    
                    if (tasksOnDate.length > 0) {
                        cell.classList.add('has-tasks');
                        
                        tasksOnDate.slice(0, 3).forEach(task => {
                            const taskDiv = document.createElement('div');
                            taskDiv.style.fontSize = '8px';
                            taskDiv.style.padding = '1px 2px';
                            taskDiv.style.marginBottom = '1px';
                            taskDiv.style.background = this.getColorHex(task.getColor());
                            taskDiv.style.color = '#000';
                            taskDiv.style.borderRadius = '2px';
                            taskDiv.style.overflow = 'hidden';
                            taskDiv.style.textOverflow = 'ellipsis';
                            taskDiv.style.whiteSpace = 'nowrap';
                            taskDiv.style.cursor = 'pointer';
                            taskDiv.textContent = task.title;
                            taskDiv.title = task.title;
                            
                            taskDiv.onclick = (e) => {
                                e.stopPropagation();
                                this.selectTask(task.id);
                                this.switchView('outline');
                            };
                            
                            cell.appendChild(taskDiv);
                        });
                        
                        if (tasksOnDate.length > 3) {
                            const moreDiv = document.createElement('div');
                            moreDiv.style.fontSize = '7px';
                            moreDiv.style.color = '#666';
                            moreDiv.style.marginTop = '1px';
                            moreDiv.textContent = `+${tasksOnDate.length - 3} more`;
                            cell.appendChild(moreDiv);
                        }
                        
                        // Make the entire cell clickable to show all appointments
                        cell.style.cursor = 'pointer';
                        cell.onclick = (e) => {
                            // Don't trigger if clicking on a task directly
                            if (e.target.title && e.target !== cell) return;
                            this.showDayDetail(dateStr, tasksOnDate);
                        };
                    }

                    grid.appendChild(cell);
                }
            },

            prevMonth() {
                const month = this.data.settings.calendarMonth;
                month.setMonth(month.getMonth() - 1);
                this.saveData();
                this.renderMiniCalendar();
            },

            nextMonth() {
                const month = this.data.settings.calendarMonth;
                month.setMonth(month.getMonth() + 1);
                this.saveData();
                this.renderMiniCalendar();
            },
            
            getColorHex(colorName) {
                const colorMap = {
                    red: '#FF6B6B',
                    green: '#51CF66',
                    blue: '#4DABF7',
                    yellow: '#FFD43B',
                    purple: '#CC5DE8',
                    pink: '#FF6BFF',
                    orange: '#FF922B'
                };
                return colorMap[colorName] || '#999';
            },

            // ============================================================================
            // UTILITY
            // ============================================================================

            updateCurrentTimeDisplay() {
                const display = document.getElementById('current-time-display');
                if (!display) return;
                
                const now = new Date();
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const dayName = days[now.getDay()];
                const hours = now.getHours();
                const minutes = now.getMinutes();
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 || 12;
                const displayMinutes = String(minutes).padStart(2, '0');
                
                display.textContent = `${dayName} ${displayHours}:${displayMinutes} ${ampm}`;
            },

            updatePlaceFilters() {
                const select = document.getElementById('place-filter');
                const taskPlace = document.getElementById('task-place');
                
                const currentPlaceValue = select.value;
                const currentTaskPlace = taskPlace.value;
                
                select.innerHTML = '<option value="all">All places</option>';
                taskPlace.innerHTML = '';
                
                this.data.places.forEach(place => {
                    const opt1 = document.createElement('option');
                    opt1.value = place.name;
                    opt1.textContent = place.name;
                    select.appendChild(opt1);
                    
                    const opt2 = document.createElement('option');
                    opt2.value = place.name;
                    opt2.textContent = place.name;
                    taskPlace.appendChild(opt2);
                });
                
                select.value = currentPlaceValue;
                taskPlace.value = currentTaskPlace;
            },

            exportData() {
                const json = JSON.stringify(this.data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'lifebalance-backup.json';
                a.click();
            },

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            
                            // Initialize taskTimers FIRST, before any other operations
                            if (!data.taskTimers) {
                                data.taskTimers = {};
                            }
                            
                            this.data = data;
                            this.data.tasks = data.tasks.map(t => Object.assign(new Task(), t));
                            this.data.places = data.places.map(p => Object.assign(new Place(), p));
                            
                            if (data.envelopes) {
                                this.data.envelopes = data.envelopes.map(e => Object.assign(new Envelope(), e));
                            }
                            if (data.incomeEnvelope) {
                                this.data.incomeEnvelope = data.incomeEnvelope;
                            }
                            
                            if (this.data.settings.calendarMonth) {
                                this.data.settings.calendarMonth = new Date(this.data.settings.calendarMonth);
                            }
                            
                            this.data.tasks.forEach(task => {
                                if (task.completedAt) {
                                    task.completedAt = new Date(task.completedAt);
                                }
                            });
                            
                            this.saveData();
                            this.render();
                            alert('Data imported successfully!');
                        } catch (err) {
                            alert('Error importing data: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            },

            // ============================================================================
            // KEYBOARD SHORTCUTS
            // ============================================================================

            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => this.handleKeyboardShortcut(e));
                console.log('‚å®Ô∏è Keyboard shortcuts enabled');
            },
            
            handleKeyboardShortcut(e) {
                // Don't intercept if user is typing in an input field
                if (e.target.tagName === 'INPUT' || 
                    e.target.tagName === 'TEXTAREA' || 
                    e.target.isContentEditable) {
                    // Except for Escape - always allow that
                    if (e.key === 'Escape') {
                        e.target.blur();
                        this.render();
                    }
                    return;
                }
                
                const ctrl = e.ctrlKey || e.metaKey; // Cmd on Mac, Ctrl on Windows
                const shift = e.shiftKey;
                
                // View switching (1-4)
                if (!ctrl && !shift && ['1', '2', '3', '4'].includes(e.key)) {
                    e.preventDefault();
                    const views = ['outline', 'todo', 'places', 'balance'];
                    this.switchView(views[parseInt(e.key) - 1]);
                    return;
                }
                
                // Ctrl/Cmd shortcuts
                if (ctrl) {
                    switch(e.key.toLowerCase()) {
                        case 'n':
                            e.preventDefault();
                            if (shift) {
                                this.addSubtask(); // Ctrl+Shift+N
                            } else {
                                this.addTask(); // Ctrl+N
                            }
                            break;
                            
                        case 'e':
                            e.preventDefault();
                            this.exportData();
                            break;
                            
                        case 'd':
                            e.preventDefault();
                            this.duplicateSelectedTask();
                            break;
                            
                        case 'u':
                            e.preventDefault();
                            this.updateTodoList();
                            break;
                            
                        case 'i':
                            e.preventDefault();
                            this.importData();
                            break;
                    }
                    return;
                }
                
                // Show keyboard help
                if (e.key === '?') {
                    e.preventDefault();
                    this.showKeyboardHelp();
                    return;
                }
                
                // Navigation and actions (no modifier keys)
                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        this.selectPreviousTask();
                        break;
                        
                    case 'ArrowDown':
                        e.preventDefault();
                        this.selectNextTask();
                        break;
                        
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.collapseSelectedTask();
                        break;
                        
                    case 'ArrowRight':
                        e.preventDefault();
                        this.expandSelectedTask();
                        break;
                        
                    case ' ': // Spacebar
                        e.preventDefault();
                        this.toggleSelectedTaskCompletion();
                        break;
                        
                    case 'Delete':
                    case 'Backspace':
                        e.preventDefault();
                        this.deleteSelectedTask();
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        this.editSelectedTask();
                        break;
                }
            },
            
            // Navigation methods
            selectPreviousTask() {
                const tasks = this.getVisibleTasks();
                if (tasks.length === 0) return;
                
                if (!this.data.settings.selectedTaskId) {
                    this.data.settings.selectedTaskId = tasks[tasks.length - 1].id;
                } else {
                    const currentIndex = tasks.findIndex(t => t.id === this.data.settings.selectedTaskId);
                    if (currentIndex > 0) {
                        this.data.settings.selectedTaskId = tasks[currentIndex - 1].id;
                    }
                }
                this.scrollToSelectedTask();
                this.render();
            },
            
            selectNextTask() {
                const tasks = this.getVisibleTasks();
                if (tasks.length === 0) return;
                
                if (!this.data.settings.selectedTaskId) {
                    this.data.settings.selectedTaskId = tasks[0].id;
                } else {
                    const currentIndex = tasks.findIndex(t => t.id === this.data.settings.selectedTaskId);
                    if (currentIndex < tasks.length - 1) {
                        this.data.settings.selectedTaskId = tasks[currentIndex + 1].id;
                    }
                }
                this.scrollToSelectedTask();
                this.render();
            },
            
            getVisibleTasks() {
                // Get all visible tasks in current view
                if (this.data.settings.currentView === 'outline') {
                    return this.getAllVisibleInOutline();
                } else if (this.data.settings.currentView === 'todo') {
                    return this.getFilteredTasks();
                }
                return [];
            },
            
            getAllVisibleInOutline() {
                const visible = [];
                const traverse = (tasks) => {
                    tasks.forEach(task => {
                        visible.push(task);
                        if (task.expanded) {
                            const children = task.getChildren();
                            if (children.length > 0) {
                                traverse(children);
                            }
                        }
                    });
                };
                const rootTasks = this.data.tasks.filter(t => t.parentId === null);
                traverse(rootTasks);
                return visible;
            },
            
            scrollToSelectedTask() {
                setTimeout(() => {
                    const element = document.querySelector(`.task-item[data-task-id="${this.data.settings.selectedTaskId}"]`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 50);
            },
            
            // Task actions
            toggleSelectedTaskCompletion() {
                if (!this.data.settings.selectedTaskId) return;
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task) {
                    this.toggleTaskCompletion(task.id);
                }
            },
            
            deleteSelectedTask() {
                if (!this.data.settings.selectedTaskId) return;
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task && confirm(`Delete "${task.title}"?`)) {
                    this.deleteTask(task.id);
                    this.data.settings.selectedTaskId = null;
                }
            },
            
            editSelectedTask() {
                if (!this.data.settings.selectedTaskId) return;
                this.selectTask(this.data.settings.selectedTaskId);
                // Focus the task title input
                setTimeout(() => {
                    const titleInput = document.getElementById('task-title');
                    if (titleInput) {
                        titleInput.focus();
                        titleInput.select();
                    }
                }, 100);
            },
            
            duplicateSelectedTask() {
                if (!this.data.settings.selectedTaskId) return;
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (!task) return;
                
                // Create a copy
                const copy = Object.assign(new Task(), task);
                copy.id = Date.now() + Math.random();
                copy.title = task.title + ' (copy)';
                copy.completed = false;
                copy.completedAt = null;
                
                this.data.tasks.push(copy);
                this.data.settings.selectedTaskId = copy.id;
                this.saveData();
                this.render();
            },
            
            collapseSelectedTask() {
                if (!this.data.settings.selectedTaskId) return;
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task && task.getChildren().length > 0) {
                    task.expanded = false;
                    this.saveData();
                    this.render();
                }
            },
            
            expandSelectedTask() {
                if (!this.data.settings.selectedTaskId) return;
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (task && task.getChildren().length > 0) {
                    task.expanded = true;
                    this.saveData();
                    this.render();
                }
            },
            
            // Show keyboard shortcuts help
            showKeyboardHelp() {
                const help = `KEYBOARD SHORTCUTS

Navigation:
  ‚Üë/‚Üì         - Select previous/next task
  ‚Üê/‚Üí         - Collapse/expand task
  1,2,3,4     - Switch views (Outline, To Do, Places, Balance)

Task Actions:
  Space       - Toggle task completion
  Enter       - Edit selected task
  Delete      - Delete selected task
  
Quick Actions:
  Ctrl+N      - New task
  Ctrl+Shift+N - New subtask
  Ctrl+D      - Duplicate task
  Ctrl+E      - Export data
  Ctrl+I      - Import data
  Ctrl+U      - Update To Do List
  
General:
  Escape      - Cancel/Close
  ?           - Show this help`;
                alert(help);
            },
            
            // Show day detail modal with all appointments
            showDayDetail(dateStr, tasks) {
                const modal = document.getElementById('day-detail-modal');
                const titleEl = document.getElementById('day-detail-title');
                const listEl = document.getElementById('day-detail-list');
                
                // Format the date nicely
                const date = new Date(dateStr + 'T00:00:00');
                const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                titleEl.textContent = date.toLocaleDateString('en-US', options);
                
                // Sort tasks by time
                const sortedTasks = [...tasks].sort((a, b) => {
                    if (!a.dueTime && !b.dueTime) return 0;
                    if (!a.dueTime) return 1;
                    if (!b.dueTime) return -1;
                    return a.dueTime.localeCompare(b.dueTime);
                });
                
                // Build the list
                listEl.innerHTML = '';
                if (sortedTasks.length === 0) {
                    listEl.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No appointments on this day</p>';
                } else {
                    sortedTasks.forEach(task => {
                        const div = document.createElement('div');
                        div.className = 'day-appointment';
                        div.style.borderLeftColor = this.getColorHex(task.getColor());
                        
                        let html = '';
                        if (task.dueTime) {
                            html += `<div class="appointment-time">üïê ${task.dueTime}</div>`;
                        }
                        html += `<div class="appointment-title">${task.title}</div>`;
                        
                        const parent = this.findTask(task.parentId);
                        if (parent) {
                            html += `<div class="appointment-context">${parent.title}</div>`;
                        }
                        
                        if (task.duration) {
                            html += `<div class="appointment-context">Duration: ${task.duration} minutes</div>`;
                        }
                        
                        if (task.note) {
                            html += `<div class="appointment-context" style="margin-top: 6px;">${task.note}</div>`;
                        }
                        
                        div.innerHTML = html;
                        div.onclick = () => {
                            this.selectTask(task.id);
                            this.switchView('outline');
                            this.closeDayDetail();
                        };
                        
                        listEl.appendChild(div);
                    });
                }
                
                modal.classList.add('active');
            },
            
            // Close day detail modal
            closeDayDetail() {
                const modal = document.getElementById('day-detail-modal');
                modal.classList.remove('active');
            },
            
            // Expand all tasks in outline
            expandAll() {
                this.data.tasks.forEach(task => {
                    if (task.getChildren().length > 0) {
                        task.expanded = true;
                    }
                });
                this.saveData();
                this.render();
            },
            
            // Collapse all tasks in outline
            collapseAll() {
                this.data.tasks.forEach(task => {
                    task.expanded = false;
                });
                this.saveData();
                this.render();
            },
            
            // Toggle outline panel expansion for full-screen planning
            toggleOutlineExpand() {
                const leftPane = document.querySelector('.left-pane');
                const button = document.getElementById('btn-expand-outline');
                
                if (leftPane.classList.contains('expanded')) {
                    leftPane.classList.remove('expanded');
                    button.textContent = '‚¨å Expand';
                    button.title = 'Expand for full-screen planning';
                } else {
                    leftPane.classList.add('expanded');
                    button.textContent = '‚¨å Collapse';
                    button.title = 'Return to split view';
                }
                
                // Recalculate container position after layout change
                setTimeout(() => fixOutlineContainerPosition(), 100);
            },
            
            // ============================================================================
            // ENVELOPE SYSTEM
            // ============================================================================
            
            updateTaskFinancialValue() {
                const task = this.findTask(this.data.settings.selectedTaskId);
                if (!task) return;
                
                const inputValue = document.getElementById('task-financial-value').value;
                const numValue = parseFloat(inputValue);
                
                // Set to the parsed number, or 0 if empty/invalid
                task.financialValue = isNaN(numValue) ? 0 : numValue;
                
                console.log('Financial value updated:', {
                    input: inputValue,
                    parsed: numValue,
                    final: task.financialValue,
                    taskId: task.id,
                    taskTitle: task.title
                });
                
                this.saveData();
                // Don't call render() to avoid tab switching
                this.renderTodoList(); // Only update todo list to show the financial badge
            },
            
            renderEnvelopesView() {
                // Update income balance
                document.getElementById('income-balance').textContent = 
                    '$' + this.data.incomeEnvelope.balance.toFixed(2);
                
                // Calculate total of all budget envelopes
                const totalBalance = this.data.envelopes.reduce((sum, env) => sum + env.balance, 0);
                document.getElementById('envelopes-total').textContent = 
                    '$' + totalBalance.toFixed(2);
                
                // Render budget envelopes
                const container = document.getElementById('budget-envelopes');
                container.innerHTML = '';
                
                if (this.data.envelopes.length === 0) {
                    container.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #666; padding: 40px;">No envelopes yet. Click "New Envelope" to create one!</p>';
                } else {
                    this.data.envelopes.forEach(envelope => {
                        const card = document.createElement('div');
                        card.className = 'envelope-card';
                        card.style.background = envelope.color;
                        
                        card.innerHTML = `
                            <div class="envelope-card-header">
                                <div class="envelope-name">${envelope.name}</div>
                                <div class="envelope-actions">
                                    <button class="envelope-btn" onclick="app.editEnvelope('${envelope.id}'); event.stopPropagation();">‚úèÔ∏è</button>
                                    <button class="envelope-btn" onclick="app.deleteEnvelope('${envelope.id}'); event.stopPropagation();">üóëÔ∏è</button>
                                </div>
                            </div>
                            <div class="envelope-balance">$${envelope.balance.toFixed(2)}</div>
                            <div class="envelope-hint">Click to add/remove money</div>
                        `;
                        
                        card.onclick = () => this.quickAdjustEnvelope(envelope.id);
                        
                        container.appendChild(card);
                    });
                }
                
                // Update transfer dropdowns
                this.updateTransferDropdowns();
                
                // Update expense dropdowns
                this.updateExpenseDropdowns();
            },
            
            createNewEnvelope() {
                const name = prompt('Envelope name:');
                if (!name) return;
                
                const colors = ['#2196F3', '#4CAF50', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#8BC34A', '#FF5722'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const envelope = new Envelope(name, color);
                this.data.envelopes.push(envelope);
                this.saveData();
                this.renderEnvelopesView();
                this.showToast(`‚úì Created envelope: ${name}`);
            },
            
            editEnvelope(envelopeId) {
                const envelope = this.data.envelopes.find(e => e.id == envelopeId);
                if (!envelope) return;
                
                const name = prompt('Envelope name:', envelope.name);
                if (name === null) return;
                
                if (name.trim()) {
                    envelope.name = name.trim();
                    
                    const color = prompt('Envelope color (hex code):', envelope.color);
                    if (color && /^#[0-9A-F]{6}$/i.test(color)) {
                        envelope.color = color;
                    }
                    
                    this.saveData();
                    this.renderEnvelopesView();
                    this.showToast(`‚úì Updated envelope: ${envelope.name}`);
                }
            },
            
            deleteEnvelope(envelopeId) {
                const envelope = this.data.envelopes.find(e => e.id == envelopeId);
                if (!envelope) return;
                
                if (envelope.balance !== 0) {
                    if (!confirm(`${envelope.name} has $${envelope.balance.toFixed(2)}. This will be returned to Income. Continue?`)) {
                        return;
                    }
                    this.data.incomeEnvelope.balance += envelope.balance;
                }
                
                if (confirm(`Delete envelope "${envelope.name}"?`)) {
                    this.data.envelopes = this.data.envelopes.filter(e => e.id != envelopeId);
                    this.saveData();
                    this.renderEnvelopesView();
                    this.showToast(`‚úì Deleted envelope: ${envelope.name}`);
                }
            },
            
            quickAdjustEnvelope(envelopeId) {
                const envelope = this.data.envelopes.find(e => e.id == envelopeId);
                if (!envelope) return;
                
                const amount = prompt(`Adjust ${envelope.name}\nCurrent: $${envelope.balance.toFixed(2)}\n\nEnter amount (+ to add, - to remove):`, '0');
                if (amount === null) return;
                
                const value = parseFloat(amount);
                if (isNaN(value) || value === 0) return;
                
                envelope.balance += value;
                this.saveData();
                this.renderEnvelopesView();
                
                const sign = value > 0 ? '+' : '';
                this.showToast(`üí∞ ${sign}$${value.toFixed(2)} ‚Üí ${envelope.name}`);
            },
            
            updateTransferDropdowns() {
                const fromSelect = document.getElementById('transfer-from');
                const toSelect = document.getElementById('transfer-to');
                
                if (!fromSelect || !toSelect) return;
                
                // Build From dropdown
                fromSelect.innerHTML = '<option value="income">Income Envelope</option>';
                this.data.envelopes.forEach(env => {
                    fromSelect.innerHTML += `<option value="${env.id}">${env.name}</option>`;
                });
                
                // Build To dropdown and reset to default
                toSelect.innerHTML = '<option value="">Select envelope...</option>';
                toSelect.innerHTML += '<option value="income">Income Envelope</option>';
                this.data.envelopes.forEach(env => {
                    toSelect.innerHTML += `<option value="${env.id}">${env.name}</option>`;
                });
                
                // Reset to default "Select envelope..." option
                toSelect.value = '';
            },
            
            transferMoney() {
                const fromId = document.getElementById('transfer-from').value;
                const toId = document.getElementById('transfer-to').value;
                const amount = parseFloat(document.getElementById('transfer-amount').value);
                
                if (!fromId || !toId) {
                    alert('Please select both From and To envelopes');
                    return;
                }
                
                if (fromId === toId) {
                    alert('Cannot transfer to the same envelope');
                    return;
                }
                
                if (isNaN(amount) || amount <= 0) {
                    alert('Please enter a valid amount');
                    return;
                }
                
                // Get source envelope
                let fromEnvelope;
                let fromName;
                if (fromId === 'income') {
                    fromEnvelope = this.data.incomeEnvelope;
                    fromName = 'Income Envelope';
                } else {
                    fromEnvelope = this.data.envelopes.find(e => e.id == fromId);
                    fromName = fromEnvelope ? fromEnvelope.name : '';
                }
                
                // Get destination envelope
                let toEnvelope;
                let toName;
                if (toId === 'income') {
                    toEnvelope = this.data.incomeEnvelope;
                    toName = 'Income Envelope';
                } else {
                    toEnvelope = this.data.envelopes.find(e => e.id == toId);
                    toName = toEnvelope ? toEnvelope.name : '';
                }
                
                if (!fromEnvelope || !toEnvelope) {
                    alert('Envelope not found. Please select valid envelopes from the dropdowns.');
                    // Reset the form
                    document.getElementById('transfer-to').value = '';
                    return;
                }
                
                if (fromEnvelope.balance < amount) {
                    alert(`Insufficient funds in ${fromName}. Available: $${fromEnvelope.balance.toFixed(2)}`);
                    return;
                }
                
                // Perform transfer
                fromEnvelope.balance -= amount;
                toEnvelope.balance += amount;
                
                // Clear form
                document.getElementById('transfer-amount').value = '';
                document.getElementById('transfer-to').value = '';
                
                this.saveData();
                this.renderEnvelopesView();
                this.showToast(`üí∏ $${amount.toFixed(2)}: ${fromName} ‚Üí ${toName}`);
            },
            
            // Expense Tracking Functions
            updateExpenseDropdowns() {
                const expenseEnvelopeSelect = document.getElementById('expense-envelope');
                if (!expenseEnvelopeSelect) return;
                
                expenseEnvelopeSelect.innerHTML = '<option value="">Select envelope...</option>';
                this.data.envelopes.forEach(env => {
                    const option = document.createElement('option');
                    option.value = String(env.id);
                    option.textContent = `${env.name} ($${env.balance.toFixed(2)})`;
                    expenseEnvelopeSelect.appendChild(option);
                });
            },
            
            logExpense() {
                // Reload data from localStorage to ensure freshness
                const saved = localStorage.getItem('lifebalance-data');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (parsed.envelopes) {
                        this.data.envelopes = parsed.envelopes.map(e => Object.assign(new Envelope(), e));
                    }
                }
                
                // Get fresh values
                const envelopeId = document.getElementById('expense-envelope').value;
                const amount = parseFloat(document.getElementById('expense-amount').value);
                const date = document.getElementById('expense-date').value;
                const description = document.getElementById('expense-description').value;
                
                if (!envelopeId || !amount || amount <= 0 || !date || !description) {
                    alert('Please fill in all expense fields');
                    return;
                }
                
                // Find envelope - try multiple comparison methods
                let envelope = this.data.envelopes.find(e => String(e.id) === String(envelopeId));
                if (!envelope) {
                    envelope = this.data.envelopes.find(e => e.id == envelopeId);
                }
                
                if (!envelope) {
                    alert('Envelope not found. Please refresh the page.');
                    return;
                }
                
                if (envelope.balance < amount) {
                    alert(`Not enough in ${envelope.name}!\n\nYou have: $${envelope.balance.toFixed(2)}\nYou need: $${amount.toFixed(2)}`);
                    return;
                }
                
                // Deduct from envelope
                envelope.balance -= amount;
                
                // Create expense record
                const expense = {
                    id: Date.now().toString(),
                    envelopeId: String(envelopeId),
                    envelopeName: envelope.name,
                    amount: amount,
                    date: date,
                    description: description,
                    timestamp: new Date().toISOString()
                };
                
                this.data.expenses.push(expense);
                
                // Clear form
                document.getElementById('expense-amount').value = '';
                document.getElementById('expense-description').value = '';
                
                this.saveData();
                this.renderEnvelopesView();
                this.renderExpenseHistory();
                this.updateExpenseDropdowns();
                this.showToast(`üí≥ $${amount.toFixed(2)} spent from ${envelope.name}`);
            },
            
            renderExpenseHistory() {
                const container = document.getElementById('expense-history');
                if (!container) return;
                
                if (this.data.expenses.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #999; padding: 40px;">No expenses logged yet</div>';
                    return;
                }
                
                // Sort expenses by date (most recent first)
                const sortedExpenses = [...this.data.expenses].sort((a, b) => 
                    new Date(b.date) - new Date(a.date)
                );
                
                container.innerHTML = sortedExpenses.map(expense => `
                    <div style="padding: 12px; border-bottom: 1px solid #E0E0E0; display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; margin-bottom: 4px;">${expense.description}</div>
                            <div style="font-size: 11px; color: #666;">
                                ${expense.envelopeName} ‚Ä¢ ${new Date(expense.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 18px; font-weight: bold; color: #F44336;">-$${expense.amount.toFixed(2)}</div>
                            <button class="btn" onclick="app.deleteExpense('${expense.id}')" style="padding: 4px 8px; font-size: 9px; margin-top: 4px;">
                                üóëÔ∏è Delete
                            </button>
                        </div>
                    </div>
                `).join('');
            },
            
            deleteExpense(expenseId) {
                if (!confirm('Delete this expense? This will NOT refund the amount to the envelope.')) {
                    return;
                }
                
                this.data.expenses = this.data.expenses.filter(e => e.id !== expenseId);
                this.saveData();
                this.renderExpenseHistory();
                this.showToast('üóëÔ∏è Expense deleted');
            },
            
            exportExpensesCSV() {
                if (this.data.expenses.length === 0) {
                    alert('No expenses to export');
                    return;
                }
                
                // Sort by date
                const sortedExpenses = [...this.data.expenses].sort((a, b) => 
                    new Date(a.date) - new Date(b.date)
                );
                
                // Create CSV content
                let csv = 'Date,Envelope,Description,Amount\n';
                sortedExpenses.forEach(expense => {
                    csv += `${expense.date},"${expense.envelopeName}","${expense.description}",${expense.amount}\n`;
                });
                
                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lifebalance-expenses-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                this.showToast('üì• CSV exported successfully');
            },
            
            // Data Log Functions
            saveLogEntry() {
                const title = document.getElementById('log-title').value;
                const content = document.getElementById('log-content').value;
                const category = document.getElementById('log-category').value;
                const date = document.getElementById('log-date').value;
                const attachmentInput = document.getElementById('log-attachment');
                const form = document.getElementById('log-form');
                const editingId = form ? form.dataset.editingId : null;
                
                if (!title || !content || !date) {
                    alert('Please fill in title, content, and date');
                    return;
                }
                
                if (editingId) {
                    // UPDATE existing entry
                    const entry = this.data.dataLog.find(e => e.id === editingId);
                    if (entry) {
                        entry.title = title;
                        entry.content = content;
                        entry.category = category;
                        entry.date = date;
                        entry.timestamp = new Date().toISOString();
                        
                        // Handle new attachments (append to existing)
                        if (attachmentInput.files.length > 0) {
                            const files = Array.from(attachmentInput.files);
                            let filesRead = 0;
                            
                            files.forEach(file => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    entry.attachments.push({
                                        name: file.name,
                                        type: file.type,
                                        size: file.size,
                                        data: e.target.result
                                    });
                                    
                                    filesRead++;
                                    if (filesRead === files.length) {
                                        this.saveData();
                                        this.renderDataLog();
                                        this.clearLogEntry();
                                        delete form.dataset.editingId;
                                        this.showToast('‚úÖ Entry updated!');
                                    }
                                };
                                reader.readAsDataURL(file);
                            });
                        } else {
                            // No new attachments
                            this.saveData();
                            this.renderDataLog();
                            this.clearLogEntry();
                            delete form.dataset.editingId;
                            this.showToast('‚úÖ Entry updated!');
                        }
                    }
                } else {
                    // CREATE new entry
                    const entry = {
                        id: Date.now().toString(),
                        title: title,
                        content: content,
                        category: category,
                        date: date,
                        timestamp: new Date().toISOString(),
                        attachments: []
                    };
                    
                    // Handle file attachments
                    if (attachmentInput.files.length > 0) {
                        const files = Array.from(attachmentInput.files);
                        files.forEach(file => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                entry.attachments.push({
                                    name: file.name,
                                    type: file.type,
                                    size: file.size,
                                    data: e.target.result
                                });
                                
                                // Save after all files are read
                                if (entry.attachments.length === files.length) {
                                    this.data.dataLog.push(entry);
                                    this.saveData();
                                    this.renderDataLog();
                                    this.clearLogEntry();
                                    this.showToast('üìì Entry saved!');
                                }
                            };
                            reader.readAsDataURL(file);
                        });
                    } else {
                        // No attachments, save immediately
                        this.data.dataLog.push(entry);
                        this.saveData();
                        this.renderDataLog();
                        this.clearLogEntry();
                        this.showToast('üìì Entry saved!');
                    }
                }
            },
            
            clearLogEntry() {
                document.getElementById('log-title').value = '';
                document.getElementById('log-content').value = '';
                document.getElementById('log-category').value = 'General';
                document.getElementById('log-date').valueAsDate = new Date();
                document.getElementById('log-attachment').value = '';
                
                // Reset button and editing state
                const form = document.getElementById('log-form');
                if (form && form.dataset.editingId) {
                    delete form.dataset.editingId;
                }
                
                const saveButton = document.querySelector('#log-form button[type="button"]');
                if (saveButton) {
                    saveButton.textContent = 'üíæ Save Entry';
                    saveButton.style.background = '#C45D5D';
                }
            },
            
            renderDayCalendar() {
                const viewMode = this.data.settings.calendarViewMode || 'day';
                
                // Update button states
                const dayBtn = document.getElementById('btn-calendar-day');
                const weekBtn = document.getElementById('btn-calendar-week');
                if (dayBtn && weekBtn) {
                    if (viewMode === 'day') {
                        dayBtn.style.background = 'var(--lb-accent-blue)';
                        dayBtn.style.color = 'white';
                        weekBtn.style.background = '';
                        weekBtn.style.color = '';
                    } else {
                        weekBtn.style.background = 'var(--lb-accent-blue)';
                        weekBtn.style.color = 'white';
                        dayBtn.style.background = '';
                        dayBtn.style.color = '';
                    }
                }
                
                if (viewMode === 'week') {
                    this.renderWeekView();
                } else {
                    this.renderDayView();
                }
            },
            
            renderDayView() {
                const container = document.getElementById('day-calendar-timeline');
                const dateDisplay = document.getElementById('day-calendar-date');
                
                if (!container || !dateDisplay) return;
                
                // Get the viewing date
                const viewDate = this.data.settings.calendarViewDate ? 
                    new Date(this.data.settings.calendarViewDate) : new Date();
                    
                const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                dateDisplay.textContent = viewDate.toLocaleDateString('en-US', options);
                
                // Get all calendar events for this date
                const dayEvents = this.getEventsForDate(viewDate);
                
                // Generate timeline for full day (midnight to midnight)
                const startHour = 0;
                const endHour = 23;
                
                let html = '';
                
                for (let hour = startHour; hour <= endHour; hour++) {
                    const hourDisplay = hour === 12 ? '12 PM' : 
                                       hour > 12 ? `${hour - 12} PM` : 
                                       hour === 0 ? '12 AM' : `${hour} AM`;
                    
                    html += `
                        <div class="timeline-hour" data-hour="${hour}">
                            <div class="hour-label">${hourDisplay}</div>
                            <div class="hour-content" id="hour-${hour}"></div>
                        </div>
                    `;
                }
                
                container.innerHTML = html;
                
                // Add click handlers to empty hour slots
                for (let hour = startHour; hour <= endHour; hour++) {
                    const hourContent = document.getElementById(`hour-${hour}`);
                    if (hourContent) {
                        hourContent.onclick = (e) => {
                            // Only trigger if clicking the empty space (not an appointment)
                            if (e.target === hourContent) {
                                this.showCalendarTaskModal(hour, 0);
                            }
                        };
                    }
                }
                
                // Place appointments in timeline
                dayEvents.forEach((event, index) => {
                    this.placeAppointment(event, index);
                });
                
                // Add note markers for data log entries
                this.addNoteMarkers(viewDate);
                
                // Add gap indicators
                this.addGapIndicators(dayEvents);
                
                // Add "now" indicator (only for today)
                const today = new Date();
                if (viewDate.toDateString() === today.toDateString()) {
                    this.addNowIndicator();
                }
            },
            
            renderWeekView() {
                const container = document.getElementById('day-calendar-timeline');
                const dateDisplay = document.getElementById('day-calendar-date');
                
                if (!container || !dateDisplay) return;
                
                // Get the viewing date and calculate week start (Sunday)
                const viewDate = this.data.settings.calendarViewDate ? 
                    new Date(this.data.settings.calendarViewDate) : new Date();
                
                const weekStart = new Date(viewDate);
                weekStart.setDate(viewDate.getDate() - viewDate.getDay()); // Go to Sunday
                
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);
                
                dateDisplay.textContent = `${weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${weekEnd.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
                
                // Generate week view for full day
                const startHour = 0;
                const endHour = 23;
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const today = new Date();
                
                let html = '<div class="week-view-container">';
                
                // Headers
                html += '<div class="week-hour-label" style="border-bottom: 3px solid #000000;"></div>';
                for (let i = 0; i < 7; i++) {
                    const dayDate = new Date(weekStart);
                    dayDate.setDate(weekStart.getDate() + i);
                    const isToday = dayDate.toDateString() === today.toDateString();
                    html += `<div class="week-day-header ${isToday ? 'today' : ''}">${days[i]}<br>${dayDate.getDate()}</div>`;
                }
                
                // Hour rows
                for (let hour = startHour; hour <= endHour; hour++) {
                    const hourDisplay = hour === 12 ? '12PM' : 
                                       hour > 12 ? `${hour - 12}PM` : 
                                       hour === 0 ? '12AM' : `${hour}AM`;
                    
                    html += `<div class="week-hour-label">${hourDisplay}</div>`;
                    
                    for (let i = 0; i < 7; i++) {
                        const dayDate = new Date(weekStart);
                        dayDate.setDate(weekStart.getDate() + i);
                        html += `<div class="week-day-column week-hour-slot" data-date="${dayDate.toISOString().split('T')[0]}" data-hour="${hour}" id="week-${i}-${hour}"></div>`;
                    }
                }
                
                html += '</div>';
                container.innerHTML = html;
                
                // Place appointments for each day
                for (let i = 0; i < 7; i++) {
                    const dayDate = new Date(weekStart);
                    dayDate.setDate(weekStart.getDate() + i);
                    const dayEvents = this.getEventsForDate(dayDate);
                    
                    dayEvents.forEach(event => {
                        this.placeWeekAppointment(event, i);
                    });
                }
            },
            
            getTodayEvents() {
                // Convenience method for getting today's events
                return this.getEventsForDate(new Date());
            },
            
            getEventsForDate(date) {
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const nextDay = new Date(targetDate);
                nextDay.setDate(nextDay.getDate() + 1);
                
                const events = [];
                
                // Get tasks with due dates and times (includes Preply lessons)
                this.data.tasks.forEach(task => {
                    if (!task.dueDate || !task.dueTime || task.done) return; // Skip tasks without time or completed tasks
                    
                    // Parse the task's date and time
                    const taskDateTime = new Date(`${task.dueDate}T${task.dueTime}`);
                    
                    if (taskDateTime >= targetDate && taskDateTime < nextDay) {
                        // Calculate end time based on duration
                        const duration = task.duration || task.estimatedEffort || 50; // default 50 minutes
                        const endTime = new Date(taskDateTime.getTime() + duration * 60000);
                        
                        // Find parent task to get color
                        const parentTask = this.data.tasks.find(t => t.id === task.parentId);
                        const parentColor = parentTask ? parentTask.color : null;
                        
                        events.push({
                            title: task.title,
                            start: taskDateTime,
                            end: endTime,
                            type: 'task',
                            taskId: task.id,
                            parentColor: parentColor,
                            isPreply: task.title.toLowerCase().includes('preply') || task.title.toLowerCase().includes('lesson')
                        });
                    }
                });
                
                // Sort by start time
                events.sort((a, b) => a.start - b.start);
                
                return events;
            },
            
            changeCalendarDate(direction) {
                const viewMode = this.data.settings.calendarViewMode || 'day';
                const currentDate = this.data.settings.calendarViewDate ? 
                    new Date(this.data.settings.calendarViewDate) : new Date();
                
                if (viewMode === 'week') {
                    // Move by 7 days
                    currentDate.setDate(currentDate.getDate() + (direction * 7));
                } else {
                    // Move by 1 day
                    currentDate.setDate(currentDate.getDate() + direction);
                }
                
                this.data.settings.calendarViewDate = currentDate;
                this.saveData();
                this.renderDayCalendar();
            },
            
            jumpToToday() {
                this.data.settings.calendarViewDate = new Date();
                this.saveData();
                this.renderDayCalendar();
            },
            
            setCalendarViewMode(mode) {
                this.data.settings.calendarViewMode = mode;
                this.saveData();
                this.renderDayCalendar();
            },
            
            quickCalendarNote() {
                const viewDate = this.data.settings.calendarViewDate ? 
                    new Date(this.data.settings.calendarViewDate) : new Date();
                const now = new Date();
                
                // Create a simple prompt modal
                const title = prompt('üìù Quick Note Title:', '');
                if (!title) return;
                
                const content = prompt('Note content:', '');
                if (!content) return;
                
                // Create timestamp on the viewed date with current time
                const noteDateTime = new Date(viewDate);
                noteDateTime.setHours(now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());
                
                // Create data log entry with timestamp
                const entry = {
                    id: Date.now().toString(),
                    title: title,
                    content: content,
                    category: 'General',
                    date: viewDate.toISOString().split('T')[0],
                    timestamp: noteDateTime.toISOString(),
                    attachments: [],
                    noteTime: `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`
                };
                
                this.data.dataLog.push(entry);
                this.saveData();
                this.renderDayCalendar(); // Refresh to show note marker
                this.showToast(`üìù Note added at ${entry.noteTime}`);
            },
            
            placeWeekAppointment(event, dayIndex) {
                const startHour = event.start.getHours();
                const startMinute = event.start.getMinutes();
                const duration = (event.end - event.start) / (1000 * 60); // duration in minutes
                const height = (duration / 60) * 60; // convert to pixels
                const startOffset = (startMinute / 60) * 60;
                
                // Find the container for this day and hour
                const container = document.getElementById(`week-${dayIndex}-${startHour}`);
                if (!container) return;
                
                // Get color based on parent task OR student name for Preply lessons
                const colorMap = {
                    red: '#D4A5A5',
                    green: '#A8C9A8',
                    blue: '#A5B8D4',
                    yellow: '#D9C9A3',
                    purple: '#C4A8D4',
                    pink: '#D4A5C9',
                    orange: '#D4B8A5'
                };
                
                let bgColor, borderColor;
                
                // For Preply lessons, use student-based color
                if (event.isPreply) {
                    // Extract student name from title (format: "StudentName - Preply lesson")
                    const studentName = event.title.split(' - ')[0];
                    bgColor = this.getStudentColor(studentName);
                    borderColor = this.darkenColor(bgColor, 20);
                } else {
                    // For regular tasks, use parent color
                    bgColor = event.parentColor ? colorMap[event.parentColor] : '#B8C5D6';
                    borderColor = event.parentColor ? this.darkenColor(bgColor, 20) : '#8A9BAE';
                }
                
                // Format time
                const formatTime = (date) => {
                    let hours = date.getHours();
                    const minutes = date.getMinutes();
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    hours = hours % 12 || 12;
                    return `${hours}:${minutes.toString().padStart(2, '0')}${ampm}`;
                };
                
                // Create appointment block
                const block = document.createElement('div');
                block.className = 'week-appointment';
                block.style.top = `${startOffset}px`;
                block.style.height = `${height}px`;
                block.style.minHeight = '20px';
                block.style.background = bgColor;
                block.style.borderColor = borderColor;
                block.dataset.taskId = event.taskId;
                
                block.innerHTML = `
                    <div class="week-appointment-title">${event.title}</div>
                    <div class="week-appointment-time">${formatTime(event.start)}</div>
                `;
                
                // Make clickable
                block.onclick = (e) => {
                    e.stopPropagation();
                    this.editCalendarTask(event.taskId);
                };
                
                container.appendChild(block);
            },
            
            darkenColor(color, percent) {
                // Convert hex to RGB
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.max(0, (num >> 16) - Math.round(255 * (percent / 100)));
                const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.round(255 * (percent / 100)));
                const b = Math.max(0, (num & 0x0000FF) - Math.round(255 * (percent / 100)));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            },
            
            getStudentColor(studentName) {
                // Generate a consistent color based on student name
                // This ensures the same student always gets the same color
                let hash = 0;
                for (let i = 0; i < studentName.length; i++) {
                    hash = studentName.charCodeAt(i) + ((hash << 5) - hash);
                }
                
                // MAXIMALLY DIFFERENT colors - spread across the entire color spectrum
                // Each color is as different as possible from the others
                const palette = [
                    '#FF0000', // Pure red
                    '#00FF00', // Pure green
                    '#0000FF', // Pure blue
                    '#FFFF00', // Pure yellow
                    '#FF00FF', // Pure magenta
                    '#00FFFF', // Pure cyan
                    '#FF8800', // Orange
                    '#8800FF', // Purple
                    '#00FF88', // Spring green
                    '#FF0088', // Deep pink
                    '#88FF00', // Chartreuse
                    '#0088FF', // Azure
                    '#FF4400', // Red-orange
                    '#44FF00', // Lime
                    '#4400FF', // Blue-violet
                    '#FF0044', // Rose
                    '#00FF44', // Sea green
                    '#0044FF', // Royal blue
                    '#FFAA00', // Amber
                    '#AA00FF', // Violet
                    '#00FFAA', // Turquoise
                    '#FF00AA', // Pink-magenta
                    '#AAFF00', // Yellow-green
                    '#00AAFF', // Sky blue
                    '#FF6600', // Bright orange
                    '#6600FF', // Indigo
                    '#00FF66', // Mint
                    '#FF0066', // Hot pink
                    '#66FF00', // Bright lime
                    '#0066FF', // Bright blue
                    '#FFCC00', // Gold
                    '#CC00FF', // Bright purple
                    '#00FFCC', // Aqua
                    '#FF00CC', // Bright pink
                    '#CCFF00', // Neon yellow
                    '#00CCFF', // Bright cyan
                ];
                
                const index = Math.abs(hash) % palette.length;
                return palette[index];
            },
            
            placeAppointment(event, index) {
                const startHour = event.start.getHours();
                const startMinute = event.start.getMinutes();
                const endHour = event.end.getHours();
                const endMinute = event.end.getMinutes();
                
                // Calculate position and height
                const startOffset = (startMinute / 60) * 60; // 60px per hour
                const duration = (event.end - event.start) / (1000 * 60); // duration in minutes
                const height = (duration / 60) * 60; // convert to pixels
                
                // Find the hour container
                const hourContainer = document.getElementById(`hour-${startHour}`);
                if (!hourContainer) return;
                
                // Format times
                const formatTime = (date) => {
                    let hours = date.getHours();
                    const minutes = date.getMinutes();
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    hours = hours % 12 || 12;
                    return `${hours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
                };
                
                // Get color based on parent task OR student name for Preply lessons
                const colorMap = {
                    red: '#D4A5A5',      // Muted red
                    green: '#A8C9A8',    // Muted green
                    blue: '#A5B8D4',     // Muted blue
                    yellow: '#D9C9A3',   // Muted yellow
                    purple: '#C4A8D4',   // Muted purple
                    pink: '#D4A5C9',     // Muted pink
                    orange: '#D4B8A5'    // Muted orange
                };
                
                let bgColor, borderColor;
                
                // For Preply lessons, use student-based color
                if (event.isPreply) {
                    // Extract student name from title (format: "StudentName - Preply lesson")
                    const studentName = event.title.split(' - ')[0];
                    bgColor = this.getStudentColor(studentName);
                    borderColor = this.darkenColor(bgColor, 20);
                } else {
                    // For regular tasks, use parent color
                    bgColor = event.parentColor ? colorMap[event.parentColor] : '#B8C5D6';
                    borderColor = event.parentColor ? this.darkenColor(bgColor, 20) : '#8A9BAE';
                }
                
                // Create appointment block
                const block = document.createElement('div');
                block.className = 'appointment-block';
                block.style.top = `${startOffset}px`;
                block.style.height = `${height}px`;
                block.style.minHeight = '40px';
                block.dataset.taskId = event.taskId;
                block.style.background = bgColor;
                block.style.borderColor = borderColor;
                
                block.innerHTML = `
                    <div class="appointment-title">${event.title}</div>
                    <div class="appointment-time">${formatTime(event.start)} - ${formatTime(event.end)}</div>
                `;
                
                // Make appointment clickable to edit
                block.onclick = (e) => {
                    e.stopPropagation();
                    this.editCalendarTask(event.taskId);
                };
                
                hourContainer.appendChild(block);
            },
            
            addGapIndicators(events) {
                for (let i = 0; i < events.length - 1; i++) {
                    const currentEnd = events[i].end;
                    const nextStart = events[i + 1].start;
                    
                    const gapMinutes = (nextStart - currentEnd) / (1000 * 60);
                    
                    // Only show gaps of 15 minutes or more
                    if (gapMinutes >= 15) {
                        const gapHours = Math.floor(gapMinutes / 60);
                        const gapMins = Math.round(gapMinutes % 60);
                        
                        let gapText = '';
                        if (gapHours > 0) {
                            gapText += `${gapHours}h `;
                        }
                        if (gapMins > 0) {
                            gapText += `${gapMins}m`;
                        }
                        gapText += ' available';
                        
                        // Place gap indicator in the middle of the gap
                        const gapMiddle = new Date((currentEnd.getTime() + nextStart.getTime()) / 2);
                        const gapHour = gapMiddle.getHours();
                        const gapMinute = gapMiddle.getMinutes();
                        
                        const hourContainer = document.getElementById(`hour-${gapHour}`);
                        if (hourContainer) {
                            const gapIndicator = document.createElement('div');
                            gapIndicator.className = 'gap-indicator';
                            gapIndicator.textContent = gapText;
                            gapIndicator.style.top = `${(gapMinute / 60) * 60}px`;
                            gapIndicator.title = 'Click to schedule a task here';
                            
                            // Make gap clickable - schedule at the end of previous task
                            gapIndicator.onclick = (e) => {
                                e.stopPropagation();
                                this.showCalendarTaskModal(currentEnd.getHours(), currentEnd.getMinutes(), Math.floor(gapMinutes));
                            };
                            
                            hourContainer.appendChild(gapIndicator);
                        }
                    }
                }
            },
            
            addNowIndicator() {
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                
                // Show for all hours (0-23)
                const hourContainer = document.getElementById(`hour-${currentHour}`);
                if (hourContainer) {
                    const nowLine = document.createElement('div');
                    nowLine.className = 'now-indicator';
                    nowLine.style.top = `${(currentMinute / 60) * 60}px`;
                    
                    hourContainer.appendChild(nowLine);
                }
            },
            
            addNoteMarkers(viewDate) {
                // Get notes for this date
                const dateStr = viewDate.toISOString().split('T')[0];
                const notes = this.data.dataLog.filter(entry => 
                    entry.date === dateStr && entry.noteTime
                );
                
                notes.forEach(note => {
                    const [hour, minute] = note.noteTime.split(':').map(Number);
                    const hourContainer = document.getElementById(`hour-${hour}`);
                    
                    if (hourContainer) {
                        const marker = document.createElement('div');
                        marker.className = 'note-marker';
                        marker.title = `${note.title} - ${note.noteTime}`;
                        marker.style.top = `${(minute / 60) * 60}px`;
                        
                        // Click to view/edit note
                        marker.onclick = (e) => {
                            e.stopPropagation();
                            this.viewCalendarNote(note.id);
                        };
                        
                        hourContainer.appendChild(marker);
                    }
                });
            },
            
            viewCalendarNote(noteId) {
                const note = this.data.dataLog.find(e => e.id === noteId);
                if (!note) return;
                
                const message = `üìù ${note.title}\n‚è∞ ${note.noteTime}\n\n${note.content}\n\nEdit in Data Log?`;
                if (confirm(message)) {
                    // Switch to data log view
                    this.switchView('datalog');
                    // Highlight or scroll to the entry (optional enhancement)
                }
            },
            
            showCalendarTaskModal(hour, minute, maxDuration = null) {
                // Create modal HTML
                const formatTime = (h, m) => {
                    const ampm = h >= 12 ? 'PM' : 'AM';
                    const displayHour = h % 12 || 12;
                    return `${displayHour}:${m.toString().padStart(2, '0')} ${ampm}`;
                };
                
                const today = new Date();
                const dateStr = today.toISOString().split('T')[0];
                const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                
                // Get list of parent tasks for dropdown
                const parentTasks = this.data.tasks.filter(t => !t.parentId);
                
                const modalHTML = `
                    <div class="calendar-modal" id="calendar-modal">
                        <div class="calendar-modal-content">
                            <div class="calendar-modal-header">‚ûï SCHEDULE NEW TASK</div>
                            <div class="calendar-modal-time">üìÖ ${formatTime(hour, minute)}</div>
                            
                            <div class="calendar-form-group">
                                <label>Task Name *</label>
                                <input type="text" id="modal-task-name" placeholder="What needs to be done?" autofocus>
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Parent Task *</label>
                                <select id="modal-task-parent">
                                    <option value="">Select a parent...</option>
                                    ${parentTasks.map(t => `<option value="${t.id}">${t.title}</option>`).join('')}
                                </select>
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Duration (minutes)</label>
                                <input type="range" id="modal-task-duration" min="15" max="${maxDuration || 240}" value="30" step="15">
                                <div class="duration-display">
                                    <span class="duration-value" id="duration-display">30 min</span>
                                    ${maxDuration ? `<span style="font-size: 11px; color: var(--lb-text-muted);">(max ${maxDuration} min in this gap)</span>` : ''}
                                </div>
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Notes (optional)</label>
                                <textarea id="modal-task-notes" rows="3" placeholder="Additional details..."></textarea>
                            </div>
                            
                            <div class="calendar-modal-buttons">
                                <button class="btn-cancel" onclick="app.closeCalendarModal()">Cancel</button>
                                <button class="btn-save" onclick="app.saveCalendarTask('${dateStr}', '${timeStr}')">Create Task</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add modal to page
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                // Update duration display on slider change
                document.getElementById('modal-task-duration').oninput = (e) => {
                    document.getElementById('duration-display').textContent = e.target.value + ' min';
                };
                
                // Focus the task name input
                setTimeout(() => document.getElementById('modal-task-name').focus(), 100);
                
                // Close on escape key
                document.addEventListener('keydown', this.handleModalEscape);
            },
            
            handleModalEscape(e) {
                if (e.key === 'Escape') {
                    app.closeCalendarModal();
                }
            },
            
            closeCalendarModal() {
                const modal = document.getElementById('calendar-modal');
                if (modal) {
                    modal.remove();
                }
                document.removeEventListener('keydown', this.handleModalEscape);
            },
            
            saveCalendarTask(dateStr, timeStr) {
                const name = document.getElementById('modal-task-name').value.trim();
                const parentId = parseFloat(document.getElementById('modal-task-parent').value);
                const duration = parseInt(document.getElementById('modal-task-duration').value);
                const notes = document.getElementById('modal-task-notes').value.trim();
                
                if (!name) {
                    alert('Please enter a task name');
                    return;
                }
                
                if (!parentId) {
                    alert('Please select a parent task');
                    return;
                }
                
                // Create new task
                const task = new Task(name, parentId);
                task.dueDate = dateStr;
                task.dueTime = timeStr;
                task.duration = duration;
                task.estimatedEffort = duration;
                task.importance = 50; // Medium importance by default
                task.note = notes;
                
                this.data.tasks.push(task);
                
                // Auto-expand the parent so user can see the new task
                const parent = this.findTask(parentId);
                if (parent) {
                    parent.expanded = true;
                }
                
                this.saveData();
                
                // Close modal and refresh ALL views
                this.closeCalendarModal();
                this.render(); // Update outline view
                this.renderDayCalendar(); // Update calendar
                this.updateTodoList(); // Update to-do list
                
                this.showToast(`‚úÖ Task scheduled: ${name}`);
            },
            
            editCalendarTask(taskId) {
                const task = this.data.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                // Get parent tasks for dropdown
                const parentTasks = this.data.tasks.filter(t => !t.parentId);
                
                // Format time for display
                const [hour, minute] = task.dueTime.split(':').map(Number);
                const formatTime = (h, m) => {
                    const ampm = h >= 12 ? 'PM' : 'AM';
                    const displayHour = h % 12 || 12;
                    return `${displayHour}:${m.toString().padStart(2, '0')} ${ampm}`;
                };
                
                const modalHTML = `
                    <div class="calendar-modal" id="calendar-modal">
                        <div class="calendar-modal-content">
                            <div class="calendar-modal-header">‚úèÔ∏è EDIT TASK</div>
                            <div class="calendar-modal-time">üìÖ ${formatTime(hour, minute)}</div>
                            
                            <div class="calendar-form-group">
                                <label>Task Name *</label>
                                <input type="text" id="modal-task-name" value="${task.title.replace(/"/g, '&quot;')}" autofocus>
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Parent Task *</label>
                                <select id="modal-task-parent">
                                    ${parentTasks.map(t => `<option value="${t.id}" ${t.id === task.parentId ? 'selected' : ''}>${t.title}</option>`).join('')}
                                </select>
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Start Time</label>
                                <input type="time" id="modal-task-time" value="${task.dueTime}">
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Duration (minutes)</label>
                                <input type="range" id="modal-task-duration" min="15" max="240" value="${task.duration || 30}" step="15">
                                <div class="duration-display">
                                    <span class="duration-value" id="duration-display">${task.duration || 30} min</span>
                                </div>
                            </div>
                            
                            <div class="calendar-form-group">
                                <label>Notes</label>
                                <textarea id="modal-task-notes" rows="3">${task.note || ''}</textarea>
                            </div>
                            
                            <div class="calendar-modal-buttons">
                                <button class="btn-delete" onclick="app.deleteCalendarTask('${taskId}')">üóëÔ∏è Delete Task</button>
                                <button class="btn-delete" onclick="app.removeCalendarTask('${taskId}')">Remove Time</button>
                                <button class="btn-cancel" onclick="app.closeCalendarModal()">Cancel</button>
                                <button class="btn-save" onclick="app.updateCalendarTask('${taskId}')">Save</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add modal to page
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                // Update duration display on slider change
                document.getElementById('modal-task-duration').oninput = (e) => {
                    document.getElementById('duration-display').textContent = e.target.value + ' min';
                };
                
                // Close on escape key
                document.addEventListener('keydown', this.handleModalEscape);
            },
            
            updateCalendarTask(taskId) {
                const task = this.data.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                const name = document.getElementById('modal-task-name').value.trim();
                const parentId = document.getElementById('modal-task-parent').value;
                const timeStr = document.getElementById('modal-task-time').value;
                const duration = parseInt(document.getElementById('modal-task-duration').value);
                const notes = document.getElementById('modal-task-notes').value.trim();
                
                if (!name) {
                    alert('Please enter a task name');
                    return;
                }
                
                // Update task
                task.title = name;
                task.parentId = parentId;
                task.dueTime = timeStr;
                task.duration = duration;
                task.estimatedEffort = duration;
                task.note = notes;
                
                this.saveData();
                this.closeCalendarModal();
                this.render(); // Update outline
                this.renderDayCalendar(); // Update calendar
                this.updateTodoList(); // Update to-do list
                
                this.showToast(`‚úÖ Task updated: ${name}`);
            },
            
            deleteCalendarTask(taskId) {
                if (!confirm('Delete this task completely? This cannot be undone.')) {
                    return;
                }
                
                const task = this.data.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                const taskName = task.title;
                
                // Remove task from data
                this.data.tasks = this.data.tasks.filter(t => t.id !== taskId);
                
                this.saveData();
                this.closeCalendarModal();
                this.render(); // Update outline
                this.renderDayCalendar(); // Update calendar
                this.updateTodoList(); // Update to-do list
                
                this.showToast(`üóëÔ∏è Deleted: ${taskName}`);
            },
            
            removeCalendarTask(taskId) {
                if (!confirm('Remove the scheduled time from this task? (Task will remain in outline)')) {
                    return;
                }
                
                const task = this.data.tasks.find(t => t.id === taskId);
                if (!task) return;
                
                task.dueDate = null;
                task.dueTime = null;
                
                this.saveData();
                this.closeCalendarModal();
                this.renderDayCalendar();
                this.render();
                
                this.showToast(`üóëÔ∏è Removed time from: ${task.title}`);
            },
            
            renderDataLog() {
                const container = document.getElementById('log-entries-container');
                if (!container) return;
                
                if (this.data.dataLog.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: #999; padding: 60px; background: var(--lb-paper); border: 3px dashed #000000;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üìì</div>
                            <div style="font-family: 'Comic Neue', cursive; font-size: 16px;">
                                Your notebook is empty. Start logging your adventures!
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Sort entries by date (most recent first)
                const sortedEntries = [...this.data.dataLog].sort((a, b) => 
                    new Date(b.date) - new Date(a.date)
                );
                
                container.innerHTML = sortedEntries.map(entry => {
                    const categoryEmoji = {
                        'General': 'üìã',
                        'Investigation': 'üîç',
                        'Adventure': 'üó∫Ô∏è',
                        'Discovery': 'üí°',
                        'Meeting': 'üë•',
                        'Research': 'üìö'
                    };
                    
                    const attachmentsHTML = entry.attachments && entry.attachments.length > 0 
                        ? `<div style="margin-top: 12px;">
                            <strong>üìé Attachments (${entry.attachments.length}):</strong>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                                ${entry.attachments.map(att => {
                                    if (att.type.startsWith('image/')) {
                                        return `<img src="${att.data}" style="max-width: 200px; max-height: 150px; border: 2px solid #000000; cursor: pointer;" onclick="window.open('${att.data}', '_blank')" title="${att.name}">`;
                                    } else {
                                        return `<a href="${att.data}" download="${att.name}" style="display: inline-block; padding: 6px 12px; background: #6F8FAF; color: white; text-decoration: none; border: 2px solid #000000; font-size: 11px;">${att.name}</a>`;
                                    }
                                }).join('')}
                            </div>
                        </div>`
                        : '';
                    
                    return `
                        <div style="background: #FFF8DC; padding: 20px; margin-bottom: 20px; border: 3px solid #000000; border-radius: 0; box-shadow: 4px 4px 0 rgba(0,0,0,0.3); position: relative;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                                <div style="flex: 1;">
                                    <div style="font-family: 'Bangers', cursive; font-size: 20px; letter-spacing: 1px; margin-bottom: 4px;">
                                        ${categoryEmoji[entry.category] || 'üìã'} ${entry.title}
                                    </div>
                                    <div style="font-size: 11px; color: #666; font-family: 'Comic Neue', cursive;">
                                        ${entry.category} ‚Ä¢ ${new Date(entry.date).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}
                                    </div>
                                </div>
                                <div style="display: flex; gap: 4px;">
                                    <button class="btn" onclick="app.editLogEntry('${entry.id}')" style="padding: 4px 8px; font-size: 9px; background: #6F8FAF; color: white;">
                                        ‚úèÔ∏è
                                    </button>
                                    <button class="btn" onclick="app.deleteLogEntry('${entry.id}')" style="padding: 4px 8px; font-size: 9px; background: #C45D5D; color: white;">
                                        üóëÔ∏è
                                    </button>
                                </div>
                            </div>
                            <div style="font-family: 'Comic Neue', cursive; font-size: 14px; line-height: 1.6; white-space: pre-wrap; background: white; padding: 12px; border: 2px solid #000000;">
                                ${entry.content}
                            </div>
                            ${attachmentsHTML}
                        </div>
                    `;
                }).join('');
            },
            
            editLogEntry(entryId) {
                const entry = this.data.dataLog.find(e => e.id === entryId);
                if (!entry) return;
                
                // Populate the form with existing data
                document.getElementById('log-title').value = entry.title;
                document.getElementById('log-content').value = entry.content;
                document.getElementById('log-category').value = entry.category;
                document.getElementById('log-date').value = entry.date;
                
                // Store the entry ID in a data attribute so we know we're editing
                const form = document.getElementById('log-form');
                if (form) {
                    form.dataset.editingId = entryId;
                }
                
                // Change button text to indicate editing
                const saveButton = document.querySelector('#log-form button[type="button"]');
                if (saveButton) {
                    saveButton.textContent = 'üíæ Update Entry';
                    saveButton.style.background = '#6F8FAF';
                }
                
                // Scroll to form
                form.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                this.showToast('‚úèÔ∏è Editing entry...');
            },
            
            deleteLogEntry(entryId) {
                if (!confirm('Delete this log entry? This cannot be undone.')) {
                    return;
                }
                
                this.data.dataLog = this.data.dataLog.filter(e => e.id !== entryId);
                this.saveData();
                this.renderDataLog();
                this.showToast('üóëÔ∏è Entry deleted');
            },
            
            exportDataLogOPML() {
                if (this.data.dataLog.length === 0) {
                    alert('No log entries to export');
                    return;
                }
                
                // Sort by date
                const sortedEntries = [...this.data.dataLog].sort((a, b) => 
                    new Date(a.date) - new Date(b.date)
                );
                
                // Create OPML structure
                let opml = `<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
    <head>
        <title>LifeBalance Data Log</title>
        <dateCreated>${new Date().toUTCString()}</dateCreated>
    </head>
    <body>
`;
                
                sortedEntries.forEach(entry => {
                    const escapedContent = entry.content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                    const attachmentNote = entry.attachments && entry.attachments.length > 0 
                        ? ` [${entry.attachments.length} attachment${entry.attachments.length > 1 ? 's' : ''}]` 
                        : '';
                    
                    opml += `        <outline text="${entry.title}" category="${entry.category}" date="${entry.date}"${attachmentNote}>
            <outline text="${escapedContent}" />
        </outline>
`;
                });
                
                opml += `    </body>
</opml>`;
                
                // Download OPML
                const blob = new Blob([opml], { type: 'text/xml' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lifebalance-datalog-${new Date().toISOString().split('T')[0]}.opml`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                this.showToast('üì§ OPML exported successfully');
            },
            
            exportDataLogJSON() {
                if (this.data.dataLog.length === 0) {
                    alert('No log entries to export');
                    return;
                }
                
                const exportData = {
                    exportDate: new Date().toISOString(),
                    entries: this.data.dataLog
                };
                
                const json = JSON.stringify(exportData, null, 2);
                
                // Download JSON
                const blob = new Blob([json], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lifebalance-datalog-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                this.showToast('üì¶ JSON exported successfully');
            }
        };

        // Initialize app when page loads
        window.onload = () => {
            app.init();
            fixOutlineContainerPosition();
        };
        
        // Fix viewport issues when returning to the app
        // This prevents the top/bottom from getting cut off on iOS
        window.addEventListener('pageshow', function(event) {
            // Force a reflow to fix viewport
            document.body.style.height = '100.1vh';
            setTimeout(() => {
                document.body.style.height = '100vh';
            }, 100);
        });
        
        // Also fix on visibility change (switching apps)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                // Force a reflow to fix viewport
                document.body.style.height = '100.1vh';
                setTimeout(() => {
                    document.body.style.height = '100vh';
                }, 100);
            }
        });
        
        // Fix outline container positioning dynamically
        function fixOutlineContainerPosition() {
            const view = document.getElementById('outline-view');
            const container = document.getElementById('outline-container');
            if (!view || !container) return;
            
            // Find the tip banner and button group
            const tipBanner = view.querySelector('div[style*="background: #FFF8DC"]');
            const buttonGroup = view.querySelector('.button-group');
            
            if (tipBanner && buttonGroup) {
                const tipHeight = tipBanner.offsetHeight;
                const buttonHeight = buttonGroup.offsetHeight;
                
                // Set inline styles to override CSS
                container.style.position = 'absolute';
                container.style.top = tipHeight + 'px';
                container.style.bottom = buttonHeight + 'px';
                container.style.left = '0';
                container.style.right = '0';
                container.style.overflowY = 'auto';
                
                console.log(`Outline container positioned: top=${tipHeight}px, bottom=${buttonHeight}px`);
            }
        }
        
        // Re-calculate on window resize
        window.addEventListener('resize', fixOutlineContainerPosition);
        
        // DIAGNOSTIC FUNCTION - Shows what's preventing scrolling
        function diagnoseScrolling() {
            const container = document.getElementById('outline-container');
            const view = document.getElementById('outline-view');
            const leftPane = document.querySelector('.left-pane');
            const mainContent = document.querySelector('.main-content');
            const appContainer = document.querySelector('.app-container');
            
            const info = {
                'outline-container': {
                    clientHeight: container.clientHeight,
                    scrollHeight: container.scrollHeight,
                    offsetHeight: container.offsetHeight,
                    overflow: getComputedStyle(container).overflow,
                    overflowY: getComputedStyle(container).overflowY,
                    height: getComputedStyle(container).height,
                    maxHeight: getComputedStyle(container).maxHeight,
                    display: getComputedStyle(container).display,
                    canScroll: container.scrollHeight > container.clientHeight
                },
                'outline-view': {
                    clientHeight: view.clientHeight,
                    scrollHeight: view.scrollHeight,
                    height: getComputedStyle(view).height,
                    maxHeight: getComputedStyle(view).maxHeight,
                    display: getComputedStyle(view).display,
                    flex: getComputedStyle(view).flex,
                    minHeight: getComputedStyle(view).minHeight
                },
                'left-pane': {
                    clientHeight: leftPane.clientHeight,
                    height: getComputedStyle(leftPane).height,
                    maxHeight: getComputedStyle(leftPane).maxHeight,
                    display: getComputedStyle(leftPane).display,
                    flex: getComputedStyle(leftPane).flex,
                    minHeight: getComputedStyle(leftPane).minHeight
                },
                'main-content': {
                    clientHeight: mainContent.clientHeight,
                    height: getComputedStyle(mainContent).height,
                    display: getComputedStyle(mainContent).display,
                    flex: getComputedStyle(mainContent).flex
                },
                'app-container': {
                    clientHeight: appContainer.clientHeight,
                    height: getComputedStyle(appContainer).height,
                    display: getComputedStyle(appContainer).display
                }
            };
            
            console.log('=== SCROLL DIAGNOSTIC ===');
            console.log(JSON.stringify(info, null, 2));
            
            alert(`SCROLL DIAGNOSTIC
            
Container scrollHeight: ${info['outline-container'].scrollHeight}px
Container clientHeight: ${info['outline-container'].clientHeight}px
CAN SCROLL: ${info['outline-container'].canScroll ? 'YES' : 'NO'}

overflow-y: ${info['outline-container'].overflowY}
height: ${info['outline-container'].height}
max-height: ${info['outline-container'].maxHeight}

Check console for full details!`);
        }
        
        // Register service worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed:', err);
                    });
            });
        }
    </script>
</body>
</html>
